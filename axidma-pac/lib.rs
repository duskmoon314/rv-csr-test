#![doc = "Peripheral access API for AXIDMA microcontrollers (generated using svd2rust v0.27.2 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.27.2/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also `modify`'ed."]
    pub trait Readable: RegisterSpec {
        #[doc = " Result from a call to `read` and argument to `modify`."]
        type Reader: From<R<Self>> + core::ops::Deref<Target = R<Self>>;
    }
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Writer type argument to `write`, et al."]
        type Writer: From<W<Self>> + core::ops::DerefMut<Target = W<Self>>;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> REG::Reader {
            REG::Reader::from(R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            })
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&REG::Reader, &'w mut REG::Writer) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &REG::Reader::from(R {
                        bits,
                        _reg: marker::PhantomData,
                    }),
                    &mut REG::Writer::from(W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    }),
                )
                .bits,
            );
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub struct R<REG: RegisterSpec + ?Sized> {
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub struct W<REG: RegisterSpec + ?Sized> {
        #[doc = "Writable bits"]
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Read datasheet or reference manual to find what values are allowed to pass."]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc(hidden)]
    pub struct FieldReaderRaw<U, T> {
        pub(crate) bits: U,
        _reg: marker::PhantomData<T>,
    }
    impl<U, FI> FieldReaderRaw<U, FI>
    where
        U: Copy,
    {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: U) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
    }
    #[doc(hidden)]
    pub struct BitReaderRaw<T> {
        pub(crate) bits: bool,
        _reg: marker::PhantomData<T>,
    }
    impl<FI> BitReaderRaw<FI> {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: bool) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<U, FI> = FieldReaderRaw<U, FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI> = BitReaderRaw<FI>;
    impl<U, FI> FieldReader<U, FI>
    where
        U: Copy,
    {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub fn bits(&self) -> U {
            self.bits
        }
    }
    impl<U, FI> PartialEq<FI> for FieldReader<U, FI>
    where
        U: PartialEq,
        FI: Copy,
        U: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&U::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    #[doc(hidden)]
    pub struct Safe;
    #[doc(hidden)]
    pub struct Unsafe;
    #[doc(hidden)]
    pub struct FieldWriterRaw<'a, U, REG, N, FI, Safety, const WI: u8, const O: u8>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        pub(crate) w: &'a mut REG::Writer,
        _field: marker::PhantomData<(N, FI, Safety)>,
    }
    impl<'a, U, REG, N, FI, Safety, const WI: u8, const O: u8>
        FieldWriterRaw<'a, U, REG, N, FI, Safety, WI, O>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Creates a new instance of the writer"]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(w: &'a mut REG::Writer) -> Self {
            Self {
                w,
                _field: marker::PhantomData,
            }
        }
    }
    #[doc(hidden)]
    pub struct BitWriterRaw<'a, U, REG, FI, M, const O: u8>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        bool: From<FI>,
    {
        pub(crate) w: &'a mut REG::Writer,
        _field: marker::PhantomData<(FI, M)>,
    }
    impl<'a, U, REG, FI, M, const O: u8> BitWriterRaw<'a, U, REG, FI, M, O>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        bool: From<FI>,
    {
        #[doc = " Creates a new instance of the writer"]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(w: &'a mut REG::Writer) -> Self {
            Self {
                w,
                _field: marker::PhantomData,
            }
        }
    }
    #[doc = " Write field Proxy with unsafe `bits`"]
    pub type FieldWriter<'a, U, REG, N, FI, const WI: u8, const O: u8> =
        FieldWriterRaw<'a, U, REG, N, FI, Unsafe, WI, O>;
    #[doc = " Write field Proxy with safe `bits`"]
    pub type FieldWriterSafe<'a, U, REG, N, FI, const WI: u8, const O: u8> =
        FieldWriterRaw<'a, U, REG, N, FI, Safe, WI, O>;
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriter<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
    }
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriterSafe<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, U, REG, FI, const O: u8> = BitWriterRaw<'a, U, REG, FI, $mwv, O>;
            impl<'a, U, REG, FI, const OF: u8> $writer<'a, U, REG, FI, OF>
            where
                REG: Writable + RegisterSpec<Ux = U>,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
            }
        };
    }
    macro_rules! impl_bit_proxy {
        ($ writer : ident) => {
            impl<'a, U, REG, FI, const OF: u8> $writer<'a, U, REG, FI, OF>
            where
                REG: Writable + RegisterSpec<Ux = U>,
                U: RawReg,
                bool: From<FI>,
            {
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut REG::Writer {
                    self.w.bits &= !(U::one() << OF);
                    self.w.bits |= (U::from(value) & U::one()) << OF;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriter<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg + From<N>,
        N: From<FI>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: N) -> &'a mut REG::Writer {
            self.w.bits &= !(U::mask::<WI>() << OF);
            self.w.bits |= (U::from(value) & U::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
            unsafe { self.bits(N::from(variant)) }
        }
    }
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriterSafe<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg + From<N>,
        N: From<FI>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn bits(self, value: N) -> &'a mut REG::Writer {
            self.w.bits &= !(U::mask::<WI>() << OF);
            self.w.bits |= (U::from(value) & U::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
            self.bits(N::from(variant))
        }
    }
    impl_bit_proxy!(BitWriter);
    impl_bit_proxy!(BitWriter1S);
    impl_bit_proxy!(BitWriter0C);
    impl_bit_proxy!(BitWriter1C);
    impl_bit_proxy!(BitWriter0S);
    impl_bit_proxy!(BitWriter1T);
    impl_bit_proxy!(BitWriter0T);
    impl<'a, U, REG, FI, const OF: u8> BitWriter<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1S<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0C<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1C<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0S<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1T<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0T<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 0] = [];
#[doc = "AXI Direct Memory Access"]
pub struct AXI_DMA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AXI_DMA {}
impl AXI_DMA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const axi_dma::RegisterBlock = 0x6010_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const axi_dma::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AXI_DMA {
    type Target = axi_dma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AXI_DMA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AXI_DMA").finish()
    }
}
#[doc = "AXI Direct Memory Access"]
pub mod axi_dma {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - MM2S DMA Control register"]
        pub mm2s_dmacr: MM2S_DMACR,
        #[doc = "0x04 - MM2S DMA Status register"]
        pub mm2s_dmasr: MM2S_DMASR,
        #[doc = "0x08 - MM2S Current Descriptor Pointer. Lower 32 bits of the address."]
        pub mm2s_curdesc: MM2S_CURDESC,
        #[doc = "0x0c - MM2S Current Descriptor Pointer. Upper 32 bits of the address."]
        pub mm2s_curdesc_msb: MM2S_CURDESC_MSB,
        #[doc = "0x10 - MM2S Tail Descriptor Pointer. Lower 32 bits of the address."]
        pub mm2s_taildesc: MM2S_TAILDESC,
        #[doc = "0x14 - MM2S Tail Descriptor Pointer. Upper 32 bits of the address."]
        pub mm2s_taildesc_msb: MM2S_TAILDESC_MSB,
        #[doc = "0x18 - MM2S Source Address. Lower 32 bits of the address."]
        pub mm2s_sa: MM2S_SA,
        #[doc = "0x1c - MM2S Source Address. Upper 32 bits of the address."]
        pub mm2s_sa_msb: MM2S_SA_MSB,
        _reserved8: [u8; 0x08],
        #[doc = "0x28 - MM2S Transfer Length (Bytes)"]
        pub mm2s_length: MM2S_LENGTH,
        #[doc = "0x2c - Scatter/Gather User and Cache"]
        pub sg_ctl: SG_CTL,
        #[doc = "0x30 - S2MM DMA Control register"]
        pub s2mm_dmacr: S2MM_DMACR,
        #[doc = "0x34 - S2MM DMA Status register"]
        pub s2mm_dmasr: S2MM_DMASR,
        #[doc = "0x38 - S2MM Current Descriptor Pointer. Lower 32 address bits."]
        pub s2mm_curdesc: S2MM_CURDESC,
        #[doc = "0x3c - S2MM Current Descriptor Pointer. Upper 32 address bits."]
        pub s2mm_curdesc_msb: S2MM_CURDESC_MSB,
        #[doc = "0x40 - S2MM Tail Descriptor Pointer. Lower 32 address bits."]
        pub s2mm_taildesc: S2MM_TAILDESC,
        #[doc = "0x44 - S2MM Tail Descriptor Pointer. Upper 32 address bits."]
        pub s2mm_taildesc_msb: S2MM_TAILDESC_MSB,
        #[doc = "0x48 - S2MM Destination Address. Lower 32 bit address"]
        pub s2mm_da: S2MM_DA,
        #[doc = "0x4c - S2MM Destination Address. Upper 32 bit address."]
        pub s2mm_da_msb: S2MM_DA_MSB,
        _reserved18: [u8; 0x08],
        #[doc = "0x58 - S2MM Buffer Length (Bytes)"]
        pub s2mm_length: S2MM_LENGTH,
    }
    #[doc = "mm2s_dmacr (rw) register accessor: an alias for `Reg<MM2S_DMACR_SPEC>`"]
    pub type MM2S_DMACR = crate::Reg<mm2s_dmacr::MM2S_DMACR_SPEC>;
    #[doc = "MM2S DMA Control register"]
    pub mod mm2s_dmacr {
        #[doc = "Register `mm2s_dmacr` reader"]
        pub struct R(crate::R<MM2S_DMACR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_DMACR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_DMACR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_DMACR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_dmacr` writer"]
        pub struct W(crate::W<MM2S_DMACR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_DMACR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_DMACR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_DMACR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `run_stop` reader - Run / Stop control for controlling running and stopping of the DMA channel."]
        pub type RUN_STOP_R = crate::BitReader<RUN_STOP_A>;
        #[doc = "Run / Stop control for controlling running and stopping of the DMA channel.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RUN_STOP_A {
            #[doc = "0: `0`"]
            STOP = 0,
            #[doc = "1: `1`"]
            RUN = 1,
        }
        impl From<RUN_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: RUN_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RUN_STOP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RUN_STOP_A {
                match self.bits {
                    false => RUN_STOP_A::STOP,
                    true => RUN_STOP_A::RUN,
                }
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == RUN_STOP_A::STOP
            }
            #[doc = "Checks if the value of the field is `RUN`"]
            #[inline(always)]
            pub fn is_run(&self) -> bool {
                *self == RUN_STOP_A::RUN
            }
        }
        #[doc = "Field `run_stop` writer - Run / Stop control for controlling running and stopping of the DMA channel."]
        pub type RUN_STOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMACR_SPEC, RUN_STOP_A, O>;
        impl<'a, const O: u8> RUN_STOP_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(RUN_STOP_A::STOP)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn run(self) -> &'a mut W {
                self.variant(RUN_STOP_A::RUN)
            }
        }
        #[doc = "Field `reset` reader - Soft reset for resetting the AXI DMA core"]
        pub type RESET_R = crate::BitReader<RESET_A>;
        #[doc = "Soft reset for resetting the AXI DMA core\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RESET_A {
            #[doc = "0: `0`"]
            NORMAL = 0,
            #[doc = "1: `1`"]
            RESET = 1,
        }
        impl From<RESET_A> for bool {
            #[inline(always)]
            fn from(variant: RESET_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RESET_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RESET_A {
                match self.bits {
                    false => RESET_A::NORMAL,
                    true => RESET_A::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == RESET_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == RESET_A::RESET
            }
        }
        #[doc = "Field `reset` writer - Soft reset for resetting the AXI DMA core"]
        pub type RESET_W<'a, const O: u8> = crate::BitWriter<'a, u32, MM2S_DMACR_SPEC, RESET_A, O>;
        impl<'a, const O: u8> RESET_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(RESET_A::NORMAL)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RESET_A::RESET)
            }
        }
        #[doc = "Field `keyhole` reader - Keyhole Read"]
        pub type KEYHOLE_R = crate::BitReader<KEYHOLE_A>;
        #[doc = "Keyhole Read\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum KEYHOLE_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<KEYHOLE_A> for bool {
            #[inline(always)]
            fn from(variant: KEYHOLE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl KEYHOLE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> KEYHOLE_A {
                match self.bits {
                    false => KEYHOLE_A::DISABLE,
                    true => KEYHOLE_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == KEYHOLE_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == KEYHOLE_A::ENABLE
            }
        }
        #[doc = "Field `keyhole` writer - Keyhole Read"]
        pub type KEYHOLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMACR_SPEC, KEYHOLE_A, O>;
        impl<'a, const O: u8> KEYHOLE_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(KEYHOLE_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(KEYHOLE_A::ENABLE)
            }
        }
        #[doc = "Field `cyclic_buffer_descriptor` reader - When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention"]
        pub type CYCLIC_BUFFER_DESCRIPTOR_R = crate::BitReader<CYCLIC_BUFFER_DESCRIPTOR_A>;
        #[doc = "When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CYCLIC_BUFFER_DESCRIPTOR_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<CYCLIC_BUFFER_DESCRIPTOR_A> for bool {
            #[inline(always)]
            fn from(variant: CYCLIC_BUFFER_DESCRIPTOR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CYCLIC_BUFFER_DESCRIPTOR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CYCLIC_BUFFER_DESCRIPTOR_A {
                match self.bits {
                    false => CYCLIC_BUFFER_DESCRIPTOR_A::DISABLE,
                    true => CYCLIC_BUFFER_DESCRIPTOR_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == CYCLIC_BUFFER_DESCRIPTOR_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == CYCLIC_BUFFER_DESCRIPTOR_A::ENABLE
            }
        }
        #[doc = "Field `cyclic_buffer_descriptor` writer - When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention"]
        pub type CYCLIC_BUFFER_DESCRIPTOR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMACR_SPEC, CYCLIC_BUFFER_DESCRIPTOR_A, O>;
        impl<'a, const O: u8> CYCLIC_BUFFER_DESCRIPTOR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(CYCLIC_BUFFER_DESCRIPTOR_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(CYCLIC_BUFFER_DESCRIPTOR_A::ENABLE)
            }
        }
        #[doc = "Field `ioc_irq_en` reader - Interrupt on Complete (IOC) Interrupt Enable"]
        pub type IOC_IRQ_EN_R = crate::BitReader<IOC_IRQ_EN_A>;
        #[doc = "Interrupt on Complete (IOC) Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IOC_IRQ_EN_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<IOC_IRQ_EN_A> for bool {
            #[inline(always)]
            fn from(variant: IOC_IRQ_EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IOC_IRQ_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IOC_IRQ_EN_A {
                match self.bits {
                    false => IOC_IRQ_EN_A::DISABLE,
                    true => IOC_IRQ_EN_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == IOC_IRQ_EN_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == IOC_IRQ_EN_A::ENABLE
            }
        }
        #[doc = "Field `ioc_irq_en` writer - Interrupt on Complete (IOC) Interrupt Enable"]
        pub type IOC_IRQ_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMACR_SPEC, IOC_IRQ_EN_A, O>;
        impl<'a, const O: u8> IOC_IRQ_EN_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(IOC_IRQ_EN_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(IOC_IRQ_EN_A::ENABLE)
            }
        }
        #[doc = "Field `dly_irq_en` reader - Interrupt on Delay Timer Interrupt Enable"]
        pub type DLY_IRQ_EN_R = crate::BitReader<DLY_IRQ_EN_A>;
        #[doc = "Interrupt on Delay Timer Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DLY_IRQ_EN_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<DLY_IRQ_EN_A> for bool {
            #[inline(always)]
            fn from(variant: DLY_IRQ_EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DLY_IRQ_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DLY_IRQ_EN_A {
                match self.bits {
                    false => DLY_IRQ_EN_A::DISABLE,
                    true => DLY_IRQ_EN_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == DLY_IRQ_EN_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == DLY_IRQ_EN_A::ENABLE
            }
        }
        #[doc = "Field `dly_irq_en` writer - Interrupt on Delay Timer Interrupt Enable"]
        pub type DLY_IRQ_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMACR_SPEC, DLY_IRQ_EN_A, O>;
        impl<'a, const O: u8> DLY_IRQ_EN_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(DLY_IRQ_EN_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(DLY_IRQ_EN_A::ENABLE)
            }
        }
        #[doc = "Field `err_irq_en` reader - Interrupt on Error Interrupt Enable"]
        pub type ERR_IRQ_EN_R = crate::BitReader<ERR_IRQ_EN_A>;
        #[doc = "Interrupt on Error Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERR_IRQ_EN_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<ERR_IRQ_EN_A> for bool {
            #[inline(always)]
            fn from(variant: ERR_IRQ_EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERR_IRQ_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERR_IRQ_EN_A {
                match self.bits {
                    false => ERR_IRQ_EN_A::DISABLE,
                    true => ERR_IRQ_EN_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == ERR_IRQ_EN_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == ERR_IRQ_EN_A::ENABLE
            }
        }
        #[doc = "Field `err_irq_en` writer - Interrupt on Error Interrupt Enable"]
        pub type ERR_IRQ_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMACR_SPEC, ERR_IRQ_EN_A, O>;
        impl<'a, const O: u8> ERR_IRQ_EN_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(ERR_IRQ_EN_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(ERR_IRQ_EN_A::ENABLE)
            }
        }
        #[doc = "Field `irq_threshold` reader - Interrupt Threshold"]
        pub type IRQ_THRESHOLD_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `irq_threshold` writer - Interrupt Threshold"]
        pub type IRQ_THRESHOLD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_DMACR_SPEC, u8, u8, 8, O>;
        #[doc = "Field `irq_delay` reader - Interrupt Delay Time Out"]
        pub type IRQ_DELAY_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `irq_delay` writer - Interrupt Delay Time Out"]
        pub type IRQ_DELAY_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_DMACR_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bit 0 - Run / Stop control for controlling running and stopping of the DMA channel."]
            #[inline(always)]
            pub fn run_stop(&self) -> RUN_STOP_R {
                RUN_STOP_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - Soft reset for resetting the AXI DMA core"]
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Keyhole Read"]
            #[inline(always)]
            pub fn keyhole(&self) -> KEYHOLE_R {
                KEYHOLE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention"]
            #[inline(always)]
            pub fn cyclic_buffer_descriptor(&self) -> CYCLIC_BUFFER_DESCRIPTOR_R {
                CYCLIC_BUFFER_DESCRIPTOR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 12 - Interrupt on Complete (IOC) Interrupt Enable"]
            #[inline(always)]
            pub fn ioc_irq_en(&self) -> IOC_IRQ_EN_R {
                IOC_IRQ_EN_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Interrupt on Delay Timer Interrupt Enable"]
            #[inline(always)]
            pub fn dly_irq_en(&self) -> DLY_IRQ_EN_R {
                DLY_IRQ_EN_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Interrupt on Error Interrupt Enable"]
            #[inline(always)]
            pub fn err_irq_en(&self) -> ERR_IRQ_EN_R {
                ERR_IRQ_EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 16:23 - Interrupt Threshold"]
            #[inline(always)]
            pub fn irq_threshold(&self) -> IRQ_THRESHOLD_R {
                IRQ_THRESHOLD_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - Interrupt Delay Time Out"]
            #[inline(always)]
            pub fn irq_delay(&self) -> IRQ_DELAY_R {
                IRQ_DELAY_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Run / Stop control for controlling running and stopping of the DMA channel."]
            #[inline(always)]
            #[must_use]
            pub fn run_stop(&mut self) -> RUN_STOP_W<0> {
                RUN_STOP_W::new(self)
            }
            #[doc = "Bit 2 - Soft reset for resetting the AXI DMA core"]
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<2> {
                RESET_W::new(self)
            }
            #[doc = "Bit 3 - Keyhole Read"]
            #[inline(always)]
            #[must_use]
            pub fn keyhole(&mut self) -> KEYHOLE_W<3> {
                KEYHOLE_W::new(self)
            }
            #[doc = "Bit 4 - When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention"]
            #[inline(always)]
            #[must_use]
            pub fn cyclic_buffer_descriptor(&mut self) -> CYCLIC_BUFFER_DESCRIPTOR_W<4> {
                CYCLIC_BUFFER_DESCRIPTOR_W::new(self)
            }
            #[doc = "Bit 12 - Interrupt on Complete (IOC) Interrupt Enable"]
            #[inline(always)]
            #[must_use]
            pub fn ioc_irq_en(&mut self) -> IOC_IRQ_EN_W<12> {
                IOC_IRQ_EN_W::new(self)
            }
            #[doc = "Bit 13 - Interrupt on Delay Timer Interrupt Enable"]
            #[inline(always)]
            #[must_use]
            pub fn dly_irq_en(&mut self) -> DLY_IRQ_EN_W<13> {
                DLY_IRQ_EN_W::new(self)
            }
            #[doc = "Bit 14 - Interrupt on Error Interrupt Enable"]
            #[inline(always)]
            #[must_use]
            pub fn err_irq_en(&mut self) -> ERR_IRQ_EN_W<14> {
                ERR_IRQ_EN_W::new(self)
            }
            #[doc = "Bits 16:23 - Interrupt Threshold"]
            #[inline(always)]
            #[must_use]
            pub fn irq_threshold(&mut self) -> IRQ_THRESHOLD_W<16> {
                IRQ_THRESHOLD_W::new(self)
            }
            #[doc = "Bits 24:31 - Interrupt Delay Time Out"]
            #[inline(always)]
            #[must_use]
            pub fn irq_delay(&mut self) -> IRQ_DELAY_W<24> {
                IRQ_DELAY_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S DMA Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_dmacr](index.html) module"]
        pub struct MM2S_DMACR_SPEC;
        impl crate::RegisterSpec for MM2S_DMACR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_dmacr::R](R) reader structure"]
        impl crate::Readable for MM2S_DMACR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_dmacr::W](W) writer structure"]
        impl crate::Writable for MM2S_DMACR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_dmacr to value 0"]
        impl crate::Resettable for MM2S_DMACR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mm2s_dmasr (rw) register accessor: an alias for `Reg<MM2S_DMASR_SPEC>`"]
    pub type MM2S_DMASR = crate::Reg<mm2s_dmasr::MM2S_DMASR_SPEC>;
    #[doc = "MM2S DMA Status register"]
    pub mod mm2s_dmasr {
        #[doc = "Register `mm2s_dmasr` reader"]
        pub struct R(crate::R<MM2S_DMASR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_DMASR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_DMASR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_DMASR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_dmasr` writer"]
        pub struct W(crate::W<MM2S_DMASR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_DMASR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_DMASR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_DMASR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `halted` reader - DMA Channel Halted. Indicates the run/stop state of the DMA channel."]
        pub type HALTED_R = crate::BitReader<HALTED_A>;
        #[doc = "DMA Channel Halted. Indicates the run/stop state of the DMA channel.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HALTED_A {
            #[doc = "0: `0`"]
            RUNNING = 0,
            #[doc = "1: `1`"]
            HALTED = 1,
        }
        impl From<HALTED_A> for bool {
            #[inline(always)]
            fn from(variant: HALTED_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HALTED_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HALTED_A {
                match self.bits {
                    false => HALTED_A::RUNNING,
                    true => HALTED_A::HALTED,
                }
            }
            #[doc = "Checks if the value of the field is `RUNNING`"]
            #[inline(always)]
            pub fn is_running(&self) -> bool {
                *self == HALTED_A::RUNNING
            }
            #[doc = "Checks if the value of the field is `HALTED`"]
            #[inline(always)]
            pub fn is_halted(&self) -> bool {
                *self == HALTED_A::HALTED
            }
        }
        #[doc = "Field `halted` writer - DMA Channel Halted. Indicates the run/stop state of the DMA channel."]
        pub type HALTED_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, HALTED_A, O>;
        impl<'a, const O: u8> HALTED_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn running(self) -> &'a mut W {
                self.variant(HALTED_A::RUNNING)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn halted(self) -> &'a mut W {
                self.variant(HALTED_A::HALTED)
            }
        }
        #[doc = "Field `idle` reader - DMA Channel Idle. Indicates the state of AXI DMA operations."]
        pub type IDLE_R = crate::BitReader<IDLE_A>;
        #[doc = "DMA Channel Idle. Indicates the state of AXI DMA operations.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IDLE_A {
            #[doc = "0: `0`"]
            NOT_IDLE = 0,
            #[doc = "1: `1`"]
            IDLE = 1,
        }
        impl From<IDLE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IDLE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IDLE_A {
                match self.bits {
                    false => IDLE_A::NOT_IDLE,
                    true => IDLE_A::IDLE,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_IDLE`"]
            #[inline(always)]
            pub fn is_not_idle(&self) -> bool {
                *self == IDLE_A::NOT_IDLE
            }
            #[doc = "Checks if the value of the field is `IDLE`"]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == IDLE_A::IDLE
            }
        }
        #[doc = "Field `idle` writer - DMA Channel Idle. Indicates the state of AXI DMA operations."]
        pub type IDLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, IDLE_A, O>;
        impl<'a, const O: u8> IDLE_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn not_idle(self) -> &'a mut W {
                self.variant(IDLE_A::NOT_IDLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn idle(self) -> &'a mut W {
                self.variant(IDLE_A::IDLE)
            }
        }
        #[doc = "Field `sg_incld` reader - Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode."]
        pub type SG_INCLD_R = crate::BitReader<SG_INCLD_A>;
        #[doc = "Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SG_INCLD_A {
            #[doc = "0: `0`"]
            SG_DISABLED = 0,
            #[doc = "1: `1`"]
            SG_ENABLED = 1,
        }
        impl From<SG_INCLD_A> for bool {
            #[inline(always)]
            fn from(variant: SG_INCLD_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SG_INCLD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SG_INCLD_A {
                match self.bits {
                    false => SG_INCLD_A::SG_DISABLED,
                    true => SG_INCLD_A::SG_ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `SG_DISABLED`"]
            #[inline(always)]
            pub fn is_sg_disabled(&self) -> bool {
                *self == SG_INCLD_A::SG_DISABLED
            }
            #[doc = "Checks if the value of the field is `SG_ENABLED`"]
            #[inline(always)]
            pub fn is_sg_enabled(&self) -> bool {
                *self == SG_INCLD_A::SG_ENABLED
            }
        }
        #[doc = "Field `sg_incld` writer - Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode."]
        pub type SG_INCLD_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, SG_INCLD_A, O>;
        impl<'a, const O: u8> SG_INCLD_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn sg_disabled(self) -> &'a mut W {
                self.variant(SG_INCLD_A::SG_DISABLED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn sg_enabled(self) -> &'a mut W {
                self.variant(SG_INCLD_A::SG_ENABLED)
            }
        }
        #[doc = "Field `dma_int_err` reader - DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0."]
        pub type DMA_INT_ERR_R = crate::BitReader<DMA_INT_ERR_A>;
        #[doc = "DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_INT_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_INT_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_INT_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_INT_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_INT_ERR_A {
                match self.bits {
                    false => DMA_INT_ERR_A::NO_ERR,
                    true => DMA_INT_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_INT_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_INT_ERR_A::DETECTED
            }
        }
        #[doc = "Field `dma_int_err` writer - DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0."]
        pub type DMA_INT_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, DMA_INT_ERR_A, O>;
        impl<'a, const O: u8> DMA_INT_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(DMA_INT_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(DMA_INT_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `dma_slv_err` reader - DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
        pub type DMA_SLV_ERR_R = crate::BitReader<DMA_SLV_ERR_A>;
        #[doc = "DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_SLV_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_SLV_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_SLV_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_SLV_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_SLV_ERR_A {
                match self.bits {
                    false => DMA_SLV_ERR_A::NO_ERR,
                    true => DMA_SLV_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_SLV_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_SLV_ERR_A::DETECTED
            }
        }
        #[doc = "Field `dma_slv_err` writer - DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
        pub type DMA_SLV_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, DMA_SLV_ERR_A, O>;
        impl<'a, const O: u8> DMA_SLV_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(DMA_SLV_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(DMA_SLV_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `dma_dec_err` reader - DMA Decode Error. This error occurs if the address request points to an invalid address."]
        pub type DMA_DEC_ERR_R = crate::BitReader<DMA_DEC_ERR_A>;
        #[doc = "DMA Decode Error. This error occurs if the address request points to an invalid address.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_DEC_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_DEC_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_DEC_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_DEC_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_DEC_ERR_A {
                match self.bits {
                    false => DMA_DEC_ERR_A::NO_ERR,
                    true => DMA_DEC_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_DEC_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_DEC_ERR_A::DETECTED
            }
        }
        #[doc = "Field `dma_dec_err` writer - DMA Decode Error. This error occurs if the address request points to an invalid address."]
        pub type DMA_DEC_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, DMA_DEC_ERR_A, O>;
        impl<'a, const O: u8> DMA_DEC_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(DMA_DEC_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(DMA_DEC_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `sg_int_err` reader - Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched."]
        pub type SG_INT_ERR_R = crate::BitReader<SG_INT_ERR_A>;
        #[doc = "Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SG_INT_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<SG_INT_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: SG_INT_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SG_INT_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SG_INT_ERR_A {
                match self.bits {
                    false => SG_INT_ERR_A::NO_ERR,
                    true => SG_INT_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == SG_INT_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == SG_INT_ERR_A::DETECTED
            }
        }
        #[doc = "Field `sg_int_err` writer - Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched."]
        pub type SG_INT_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, SG_INT_ERR_A, O>;
        impl<'a, const O: u8> SG_INT_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(SG_INT_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(SG_INT_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `sg_slv_err` reader - Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error."]
        pub type SG_SLV_ERR_R = crate::BitReader<SG_SLV_ERR_A>;
        #[doc = "Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SG_SLV_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<SG_SLV_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: SG_SLV_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SG_SLV_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SG_SLV_ERR_A {
                match self.bits {
                    false => SG_SLV_ERR_A::NO_ERR,
                    true => SG_SLV_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == SG_SLV_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == SG_SLV_ERR_A::DETECTED
            }
        }
        #[doc = "Field `sg_slv_err` writer - Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error."]
        pub type SG_SLV_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, SG_SLV_ERR_A, O>;
        impl<'a, const O: u8> SG_SLV_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(SG_SLV_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(SG_SLV_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `sg_dec_err` reader - Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address."]
        pub type SG_DEC_ERR_R = crate::BitReader<SG_DEC_ERR_A>;
        #[doc = "Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SG_DEC_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<SG_DEC_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: SG_DEC_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SG_DEC_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SG_DEC_ERR_A {
                match self.bits {
                    false => SG_DEC_ERR_A::NO_ERR,
                    true => SG_DEC_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == SG_DEC_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == SG_DEC_ERR_A::DETECTED
            }
        }
        #[doc = "Field `sg_dec_err` writer - Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address."]
        pub type SG_DEC_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, SG_DEC_ERR_A, O>;
        impl<'a, const O: u8> SG_DEC_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(SG_DEC_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(SG_DEC_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `ioc_irq` reader - Interrupt on Complete (IOC)"]
        pub type IOC_IRQ_R = crate::BitReader<IOC_IRQ_A>;
        #[doc = "Interrupt on Complete (IOC)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IOC_IRQ_A {
            #[doc = "0: `0`"]
            NO_INTR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<IOC_IRQ_A> for bool {
            #[inline(always)]
            fn from(variant: IOC_IRQ_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IOC_IRQ_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IOC_IRQ_A {
                match self.bits {
                    false => IOC_IRQ_A::NO_INTR,
                    true => IOC_IRQ_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTR`"]
            #[inline(always)]
            pub fn is_no_intr(&self) -> bool {
                *self == IOC_IRQ_A::NO_INTR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == IOC_IRQ_A::DETECTED
            }
        }
        #[doc = "Field `ioc_irq` writer - Interrupt on Complete (IOC)"]
        pub type IOC_IRQ_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, IOC_IRQ_A, O>;
        impl<'a, const O: u8> IOC_IRQ_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_intr(self) -> &'a mut W {
                self.variant(IOC_IRQ_A::NO_INTR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(IOC_IRQ_A::DETECTED)
            }
        }
        #[doc = "Field `dly_irq` reader - Interrupt on Delay Timer"]
        pub type DLY_IRQ_R = crate::BitReader<DLY_IRQ_A>;
        #[doc = "Interrupt on Delay Timer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DLY_IRQ_A {
            #[doc = "0: `0`"]
            NO_INTR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DLY_IRQ_A> for bool {
            #[inline(always)]
            fn from(variant: DLY_IRQ_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DLY_IRQ_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DLY_IRQ_A {
                match self.bits {
                    false => DLY_IRQ_A::NO_INTR,
                    true => DLY_IRQ_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTR`"]
            #[inline(always)]
            pub fn is_no_intr(&self) -> bool {
                *self == DLY_IRQ_A::NO_INTR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DLY_IRQ_A::DETECTED
            }
        }
        #[doc = "Field `dly_irq` writer - Interrupt on Delay Timer"]
        pub type DLY_IRQ_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, DLY_IRQ_A, O>;
        impl<'a, const O: u8> DLY_IRQ_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_intr(self) -> &'a mut W {
                self.variant(DLY_IRQ_A::NO_INTR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(DLY_IRQ_A::DETECTED)
            }
        }
        #[doc = "Field `err_irq` reader - Interrupt on Error"]
        pub type ERR_IRQ_R = crate::BitReader<ERR_IRQ_A>;
        #[doc = "Interrupt on Error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERR_IRQ_A {
            #[doc = "0: `0`"]
            NO_INTR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<ERR_IRQ_A> for bool {
            #[inline(always)]
            fn from(variant: ERR_IRQ_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERR_IRQ_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERR_IRQ_A {
                match self.bits {
                    false => ERR_IRQ_A::NO_INTR,
                    true => ERR_IRQ_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTR`"]
            #[inline(always)]
            pub fn is_no_intr(&self) -> bool {
                *self == ERR_IRQ_A::NO_INTR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == ERR_IRQ_A::DETECTED
            }
        }
        #[doc = "Field `err_irq` writer - Interrupt on Error"]
        pub type ERR_IRQ_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, MM2S_DMASR_SPEC, ERR_IRQ_A, O>;
        impl<'a, const O: u8> ERR_IRQ_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_intr(self) -> &'a mut W {
                self.variant(ERR_IRQ_A::NO_INTR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(ERR_IRQ_A::DETECTED)
            }
        }
        #[doc = "Field `irq_threshold_sts` reader - Interrupt Threshold Status. Indicates current interrupt threshold value."]
        pub type IRQ_THRESHOLD_STS_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `irq_threshold_sts` writer - Interrupt Threshold Status. Indicates current interrupt threshold value."]
        pub type IRQ_THRESHOLD_STS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_DMASR_SPEC, u8, u8, 8, O>;
        #[doc = "Field `irq_delay_sts` reader - Interrupt Delay Time Status. Indicates current interrupt delay time value."]
        pub type IRQ_DELAY_STS_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `irq_delay_sts` writer - Interrupt Delay Time Status. Indicates current interrupt delay time value."]
        pub type IRQ_DELAY_STS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_DMASR_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bit 0 - DMA Channel Halted. Indicates the run/stop state of the DMA channel."]
            #[inline(always)]
            pub fn halted(&self) -> HALTED_R {
                HALTED_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - DMA Channel Idle. Indicates the state of AXI DMA operations."]
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode."]
            #[inline(always)]
            pub fn sg_incld(&self) -> SG_INCLD_R {
                SG_INCLD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0."]
            #[inline(always)]
            pub fn dma_int_err(&self) -> DMA_INT_ERR_R {
                DMA_INT_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
            #[inline(always)]
            pub fn dma_slv_err(&self) -> DMA_SLV_ERR_R {
                DMA_SLV_ERR_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - DMA Decode Error. This error occurs if the address request points to an invalid address."]
            #[inline(always)]
            pub fn dma_dec_err(&self) -> DMA_DEC_ERR_R {
                DMA_DEC_ERR_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched."]
            #[inline(always)]
            pub fn sg_int_err(&self) -> SG_INT_ERR_R {
                SG_INT_ERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error."]
            #[inline(always)]
            pub fn sg_slv_err(&self) -> SG_SLV_ERR_R {
                SG_SLV_ERR_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address."]
            #[inline(always)]
            pub fn sg_dec_err(&self) -> SG_DEC_ERR_R {
                SG_DEC_ERR_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 12 - Interrupt on Complete (IOC)"]
            #[inline(always)]
            pub fn ioc_irq(&self) -> IOC_IRQ_R {
                IOC_IRQ_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Interrupt on Delay Timer"]
            #[inline(always)]
            pub fn dly_irq(&self) -> DLY_IRQ_R {
                DLY_IRQ_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Interrupt on Error"]
            #[inline(always)]
            pub fn err_irq(&self) -> ERR_IRQ_R {
                ERR_IRQ_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 16:23 - Interrupt Threshold Status. Indicates current interrupt threshold value."]
            #[inline(always)]
            pub fn irq_threshold_sts(&self) -> IRQ_THRESHOLD_STS_R {
                IRQ_THRESHOLD_STS_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - Interrupt Delay Time Status. Indicates current interrupt delay time value."]
            #[inline(always)]
            pub fn irq_delay_sts(&self) -> IRQ_DELAY_STS_R {
                IRQ_DELAY_STS_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - DMA Channel Halted. Indicates the run/stop state of the DMA channel."]
            #[inline(always)]
            #[must_use]
            pub fn halted(&mut self) -> HALTED_W<0> {
                HALTED_W::new(self)
            }
            #[doc = "Bit 1 - DMA Channel Idle. Indicates the state of AXI DMA operations."]
            #[inline(always)]
            #[must_use]
            pub fn idle(&mut self) -> IDLE_W<1> {
                IDLE_W::new(self)
            }
            #[doc = "Bit 3 - Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode."]
            #[inline(always)]
            #[must_use]
            pub fn sg_incld(&mut self) -> SG_INCLD_W<3> {
                SG_INCLD_W::new(self)
            }
            #[doc = "Bit 4 - DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0."]
            #[inline(always)]
            #[must_use]
            pub fn dma_int_err(&mut self) -> DMA_INT_ERR_W<4> {
                DMA_INT_ERR_W::new(self)
            }
            #[doc = "Bit 5 - DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
            #[inline(always)]
            #[must_use]
            pub fn dma_slv_err(&mut self) -> DMA_SLV_ERR_W<5> {
                DMA_SLV_ERR_W::new(self)
            }
            #[doc = "Bit 6 - DMA Decode Error. This error occurs if the address request points to an invalid address."]
            #[inline(always)]
            #[must_use]
            pub fn dma_dec_err(&mut self) -> DMA_DEC_ERR_W<6> {
                DMA_DEC_ERR_W::new(self)
            }
            #[doc = "Bit 8 - Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched."]
            #[inline(always)]
            #[must_use]
            pub fn sg_int_err(&mut self) -> SG_INT_ERR_W<8> {
                SG_INT_ERR_W::new(self)
            }
            #[doc = "Bit 9 - Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error."]
            #[inline(always)]
            #[must_use]
            pub fn sg_slv_err(&mut self) -> SG_SLV_ERR_W<9> {
                SG_SLV_ERR_W::new(self)
            }
            #[doc = "Bit 10 - Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address."]
            #[inline(always)]
            #[must_use]
            pub fn sg_dec_err(&mut self) -> SG_DEC_ERR_W<10> {
                SG_DEC_ERR_W::new(self)
            }
            #[doc = "Bit 12 - Interrupt on Complete (IOC)"]
            #[inline(always)]
            #[must_use]
            pub fn ioc_irq(&mut self) -> IOC_IRQ_W<12> {
                IOC_IRQ_W::new(self)
            }
            #[doc = "Bit 13 - Interrupt on Delay Timer"]
            #[inline(always)]
            #[must_use]
            pub fn dly_irq(&mut self) -> DLY_IRQ_W<13> {
                DLY_IRQ_W::new(self)
            }
            #[doc = "Bit 14 - Interrupt on Error"]
            #[inline(always)]
            #[must_use]
            pub fn err_irq(&mut self) -> ERR_IRQ_W<14> {
                ERR_IRQ_W::new(self)
            }
            #[doc = "Bits 16:23 - Interrupt Threshold Status. Indicates current interrupt threshold value."]
            #[inline(always)]
            #[must_use]
            pub fn irq_threshold_sts(&mut self) -> IRQ_THRESHOLD_STS_W<16> {
                IRQ_THRESHOLD_STS_W::new(self)
            }
            #[doc = "Bits 24:31 - Interrupt Delay Time Status. Indicates current interrupt delay time value."]
            #[inline(always)]
            #[must_use]
            pub fn irq_delay_sts(&mut self) -> IRQ_DELAY_STS_W<24> {
                IRQ_DELAY_STS_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S DMA Status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_dmasr](index.html) module"]
        pub struct MM2S_DMASR_SPEC;
        impl crate::RegisterSpec for MM2S_DMASR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_dmasr::R](R) reader structure"]
        impl crate::Readable for MM2S_DMASR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_dmasr::W](W) writer structure"]
        impl crate::Writable for MM2S_DMASR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_dmasr to value 0"]
        impl crate::Resettable for MM2S_DMASR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mm2s_curdesc (rw) register accessor: an alias for `Reg<MM2S_CURDESC_SPEC>`"]
    pub type MM2S_CURDESC = crate::Reg<mm2s_curdesc::MM2S_CURDESC_SPEC>;
    #[doc = "MM2S Current Descriptor Pointer. Lower 32 bits of the address."]
    pub mod mm2s_curdesc {
        #[doc = "Register `mm2s_curdesc` reader"]
        pub struct R(crate::R<MM2S_CURDESC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_CURDESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_CURDESC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_CURDESC_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_curdesc` writer"]
        pub struct W(crate::W<MM2S_CURDESC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_CURDESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_CURDESC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_CURDESC_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `curdesc_ptr` reader - Indicates the pointer of the current descriptor being worked on."]
        pub type CURDESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `curdesc_ptr` writer - Indicates the pointer of the current descriptor being worked on."]
        pub type CURDESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_CURDESC_SPEC, u32, u32, 26, O>;
        impl R {
            #[doc = "Bits 6:31 - Indicates the pointer of the current descriptor being worked on."]
            #[inline(always)]
            pub fn curdesc_ptr(&self) -> CURDESC_PTR_R {
                CURDESC_PTR_R::new((self.bits >> 6) & 0x03ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 6:31 - Indicates the pointer of the current descriptor being worked on."]
            #[inline(always)]
            #[must_use]
            pub fn curdesc_ptr(&mut self) -> CURDESC_PTR_W<6> {
                CURDESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S Current Descriptor Pointer. Lower 32 bits of the address.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_curdesc](index.html) module"]
        pub struct MM2S_CURDESC_SPEC;
        impl crate::RegisterSpec for MM2S_CURDESC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_curdesc::R](R) reader structure"]
        impl crate::Readable for MM2S_CURDESC_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_curdesc::W](W) writer structure"]
        impl crate::Writable for MM2S_CURDESC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_curdesc to value 0"]
        impl crate::Resettable for MM2S_CURDESC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mm2s_curdesc_msb (rw) register accessor: an alias for `Reg<MM2S_CURDESC_MSB_SPEC>`"]
    pub type MM2S_CURDESC_MSB = crate::Reg<mm2s_curdesc_msb::MM2S_CURDESC_MSB_SPEC>;
    #[doc = "MM2S Current Descriptor Pointer. Upper 32 bits of the address."]
    pub mod mm2s_curdesc_msb {
        #[doc = "Register `mm2s_curdesc_msb` reader"]
        pub struct R(crate::R<MM2S_CURDESC_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_CURDESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_CURDESC_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_CURDESC_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_curdesc_msb` writer"]
        pub struct W(crate::W<MM2S_CURDESC_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_CURDESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_CURDESC_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_CURDESC_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `curdesc_ptr` reader - Indicates the pointer of the current descriptor being worked on."]
        pub type CURDESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `curdesc_ptr` writer - Indicates the pointer of the current descriptor being worked on."]
        pub type CURDESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_CURDESC_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the pointer of the current descriptor being worked on."]
            #[inline(always)]
            pub fn curdesc_ptr(&self) -> CURDESC_PTR_R {
                CURDESC_PTR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the pointer of the current descriptor being worked on."]
            #[inline(always)]
            #[must_use]
            pub fn curdesc_ptr(&mut self) -> CURDESC_PTR_W<0> {
                CURDESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S Current Descriptor Pointer. Upper 32 bits of the address.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_curdesc_msb](index.html) module"]
        pub struct MM2S_CURDESC_MSB_SPEC;
        impl crate::RegisterSpec for MM2S_CURDESC_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_curdesc_msb::R](R) reader structure"]
        impl crate::Readable for MM2S_CURDESC_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_curdesc_msb::W](W) writer structure"]
        impl crate::Writable for MM2S_CURDESC_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_curdesc_msb to value 0"]
        impl crate::Resettable for MM2S_CURDESC_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mm2s_taildesc (rw) register accessor: an alias for `Reg<MM2S_TAILDESC_SPEC>`"]
    pub type MM2S_TAILDESC = crate::Reg<mm2s_taildesc::MM2S_TAILDESC_SPEC>;
    #[doc = "MM2S Tail Descriptor Pointer. Lower 32 bits of the address."]
    pub mod mm2s_taildesc {
        #[doc = "Register `mm2s_taildesc` reader"]
        pub struct R(crate::R<MM2S_TAILDESC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_TAILDESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_TAILDESC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_TAILDESC_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_taildesc` writer"]
        pub struct W(crate::W<MM2S_TAILDESC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_TAILDESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_TAILDESC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_TAILDESC_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `taildesc_ptr` reader - Indicates the pause pointer in a descriptor chain."]
        pub type TAILDESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `taildesc_ptr` writer - Indicates the pause pointer in a descriptor chain."]
        pub type TAILDESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_TAILDESC_SPEC, u32, u32, 26, O>;
        impl R {
            #[doc = "Bits 6:31 - Indicates the pause pointer in a descriptor chain."]
            #[inline(always)]
            pub fn taildesc_ptr(&self) -> TAILDESC_PTR_R {
                TAILDESC_PTR_R::new((self.bits >> 6) & 0x03ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 6:31 - Indicates the pause pointer in a descriptor chain."]
            #[inline(always)]
            #[must_use]
            pub fn taildesc_ptr(&mut self) -> TAILDESC_PTR_W<6> {
                TAILDESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S Tail Descriptor Pointer. Lower 32 bits of the address.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_taildesc](index.html) module"]
        pub struct MM2S_TAILDESC_SPEC;
        impl crate::RegisterSpec for MM2S_TAILDESC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_taildesc::R](R) reader structure"]
        impl crate::Readable for MM2S_TAILDESC_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_taildesc::W](W) writer structure"]
        impl crate::Writable for MM2S_TAILDESC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_taildesc to value 0"]
        impl crate::Resettable for MM2S_TAILDESC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mm2s_taildesc_msb (rw) register accessor: an alias for `Reg<MM2S_TAILDESC_MSB_SPEC>`"]
    pub type MM2S_TAILDESC_MSB = crate::Reg<mm2s_taildesc_msb::MM2S_TAILDESC_MSB_SPEC>;
    #[doc = "MM2S Tail Descriptor Pointer. Upper 32 bits of the address."]
    pub mod mm2s_taildesc_msb {
        #[doc = "Register `mm2s_taildesc_msb` reader"]
        pub struct R(crate::R<MM2S_TAILDESC_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_TAILDESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_TAILDESC_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_TAILDESC_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_taildesc_msb` writer"]
        pub struct W(crate::W<MM2S_TAILDESC_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_TAILDESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_TAILDESC_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_TAILDESC_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `taildesc_ptr` reader - Indicates the pause pointer in a descriptor chain."]
        pub type TAILDESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `taildesc_ptr` writer - Indicates the pause pointer in a descriptor chain."]
        pub type TAILDESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_TAILDESC_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the pause pointer in a descriptor chain."]
            #[inline(always)]
            pub fn taildesc_ptr(&self) -> TAILDESC_PTR_R {
                TAILDESC_PTR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the pause pointer in a descriptor chain."]
            #[inline(always)]
            #[must_use]
            pub fn taildesc_ptr(&mut self) -> TAILDESC_PTR_W<0> {
                TAILDESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S Tail Descriptor Pointer. Upper 32 bits of the address.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_taildesc_msb](index.html) module"]
        pub struct MM2S_TAILDESC_MSB_SPEC;
        impl crate::RegisterSpec for MM2S_TAILDESC_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_taildesc_msb::R](R) reader structure"]
        impl crate::Readable for MM2S_TAILDESC_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_taildesc_msb::W](W) writer structure"]
        impl crate::Writable for MM2S_TAILDESC_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_taildesc_msb to value 0"]
        impl crate::Resettable for MM2S_TAILDESC_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mm2s_sa (rw) register accessor: an alias for `Reg<MM2S_SA_SPEC>`"]
    pub type MM2S_SA = crate::Reg<mm2s_sa::MM2S_SA_SPEC>;
    #[doc = "MM2S Source Address. Lower 32 bits of the address."]
    pub mod mm2s_sa {
        #[doc = "Register `mm2s_sa` reader"]
        pub struct R(crate::R<MM2S_SA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_SA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_SA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_SA_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_sa` writer"]
        pub struct W(crate::W<MM2S_SA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_SA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_SA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_SA_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `src_addr` reader - Indicates the source address AXI DMA reads from to transfer data to AXI4-Stream on the MM2S Channel."]
        pub type SRC_ADDR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `src_addr` writer - Indicates the source address AXI DMA reads from to transfer data to AXI4-Stream on the MM2S Channel."]
        pub type SRC_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_SA_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the source address AXI DMA reads from to transfer data to AXI4-Stream on the MM2S Channel."]
            #[inline(always)]
            pub fn src_addr(&self) -> SRC_ADDR_R {
                SRC_ADDR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the source address AXI DMA reads from to transfer data to AXI4-Stream on the MM2S Channel."]
            #[inline(always)]
            #[must_use]
            pub fn src_addr(&mut self) -> SRC_ADDR_W<0> {
                SRC_ADDR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S Source Address. Lower 32 bits of the address.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_sa](index.html) module"]
        pub struct MM2S_SA_SPEC;
        impl crate::RegisterSpec for MM2S_SA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_sa::R](R) reader structure"]
        impl crate::Readable for MM2S_SA_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_sa::W](W) writer structure"]
        impl crate::Writable for MM2S_SA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_sa to value 0"]
        impl crate::Resettable for MM2S_SA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mm2s_sa_msb (rw) register accessor: an alias for `Reg<MM2S_SA_MSB_SPEC>`"]
    pub type MM2S_SA_MSB = crate::Reg<mm2s_sa_msb::MM2S_SA_MSB_SPEC>;
    #[doc = "MM2S Source Address. Upper 32 bits of the address."]
    pub mod mm2s_sa_msb {
        #[doc = "Register `mm2s_sa_msb` reader"]
        pub struct R(crate::R<MM2S_SA_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_SA_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_SA_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_SA_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_sa_msb` writer"]
        pub struct W(crate::W<MM2S_SA_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_SA_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_SA_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_SA_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `src_addr` reader - Indicates the MSB 32 bits of the source address AXI DMA reads from totransfer data to AXI4-Stream on the MM2S Channel."]
        pub type SRC_ADDR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `src_addr` writer - Indicates the MSB 32 bits of the source address AXI DMA reads from totransfer data to AXI4-Stream on the MM2S Channel."]
        pub type SRC_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_SA_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the MSB 32 bits of the source address AXI DMA reads from totransfer data to AXI4-Stream on the MM2S Channel."]
            #[inline(always)]
            pub fn src_addr(&self) -> SRC_ADDR_R {
                SRC_ADDR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the MSB 32 bits of the source address AXI DMA reads from totransfer data to AXI4-Stream on the MM2S Channel."]
            #[inline(always)]
            #[must_use]
            pub fn src_addr(&mut self) -> SRC_ADDR_W<0> {
                SRC_ADDR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S Source Address. Upper 32 bits of the address.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_sa_msb](index.html) module"]
        pub struct MM2S_SA_MSB_SPEC;
        impl crate::RegisterSpec for MM2S_SA_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_sa_msb::R](R) reader structure"]
        impl crate::Readable for MM2S_SA_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_sa_msb::W](W) writer structure"]
        impl crate::Writable for MM2S_SA_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_sa_msb to value 0"]
        impl crate::Resettable for MM2S_SA_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mm2s_length (rw) register accessor: an alias for `Reg<MM2S_LENGTH_SPEC>`"]
    pub type MM2S_LENGTH = crate::Reg<mm2s_length::MM2S_LENGTH_SPEC>;
    #[doc = "MM2S Transfer Length (Bytes)"]
    pub mod mm2s_length {
        #[doc = "Register `mm2s_length` reader"]
        pub struct R(crate::R<MM2S_LENGTH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MM2S_LENGTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MM2S_LENGTH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MM2S_LENGTH_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mm2s_length` writer"]
        pub struct W(crate::W<MM2S_LENGTH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MM2S_LENGTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MM2S_LENGTH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MM2S_LENGTH_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `length` reader - Indicates the number of bytes to transfer for the MM2S channel."]
        pub type LENGTH_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `length` writer - Indicates the number of bytes to transfer for the MM2S channel."]
        pub type LENGTH_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MM2S_LENGTH_SPEC, u32, u32, 26, O>;
        impl R {
            #[doc = "Bits 0:25 - Indicates the number of bytes to transfer for the MM2S channel."]
            #[inline(always)]
            pub fn length(&self) -> LENGTH_R {
                LENGTH_R::new(self.bits & 0x03ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 0:25 - Indicates the number of bytes to transfer for the MM2S channel."]
            #[inline(always)]
            #[must_use]
            pub fn length(&mut self) -> LENGTH_W<0> {
                LENGTH_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "MM2S Transfer Length (Bytes)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mm2s_length](index.html) module"]
        pub struct MM2S_LENGTH_SPEC;
        impl crate::RegisterSpec for MM2S_LENGTH_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mm2s_length::R](R) reader structure"]
        impl crate::Readable for MM2S_LENGTH_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mm2s_length::W](W) writer structure"]
        impl crate::Writable for MM2S_LENGTH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mm2s_length to value 0"]
        impl crate::Resettable for MM2S_LENGTH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "sg_ctl (rw) register accessor: an alias for `Reg<SG_CTL_SPEC>`"]
    pub type SG_CTL = crate::Reg<sg_ctl::SG_CTL_SPEC>;
    #[doc = "Scatter/Gather User and Cache"]
    pub mod sg_ctl {
        #[doc = "Register `sg_ctl` reader"]
        pub struct R(crate::R<SG_CTL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SG_CTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SG_CTL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SG_CTL_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `sg_ctl` writer"]
        pub struct W(crate::W<SG_CTL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SG_CTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SG_CTL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SG_CTL_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `sg_cache` reader - Scatter/Gather Cache Control. Values written in this register reflect on the m_axi_sg_arcache and m_axi_sg_awcache signals of the M_AXI_SG interface."]
        pub type SG_CACHE_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `sg_cache` writer - Scatter/Gather Cache Control. Values written in this register reflect on the m_axi_sg_arcache and m_axi_sg_awcache signals of the M_AXI_SG interface."]
        pub type SG_CACHE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SG_CTL_SPEC, u8, u8, 4, O>;
        #[doc = "Field `sg_user` reader - Scatter/Gather User Control. Values written in this register reflect on the m_axi_sg_aruser and m_axi_sg_awuser signals of the M_AXI_SG interface."]
        pub type SG_USER_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `sg_user` writer - Scatter/Gather User Control. Values written in this register reflect on the m_axi_sg_aruser and m_axi_sg_awuser signals of the M_AXI_SG interface."]
        pub type SG_USER_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SG_CTL_SPEC, u8, u8, 4, O>;
        impl R {
            #[doc = "Bits 0:3 - Scatter/Gather Cache Control. Values written in this register reflect on the m_axi_sg_arcache and m_axi_sg_awcache signals of the M_AXI_SG interface."]
            #[inline(always)]
            pub fn sg_cache(&self) -> SG_CACHE_R {
                SG_CACHE_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - Scatter/Gather User Control. Values written in this register reflect on the m_axi_sg_aruser and m_axi_sg_awuser signals of the M_AXI_SG interface."]
            #[inline(always)]
            pub fn sg_user(&self) -> SG_USER_R {
                SG_USER_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Scatter/Gather Cache Control. Values written in this register reflect on the m_axi_sg_arcache and m_axi_sg_awcache signals of the M_AXI_SG interface."]
            #[inline(always)]
            #[must_use]
            pub fn sg_cache(&mut self) -> SG_CACHE_W<0> {
                SG_CACHE_W::new(self)
            }
            #[doc = "Bits 8:11 - Scatter/Gather User Control. Values written in this register reflect on the m_axi_sg_aruser and m_axi_sg_awuser signals of the M_AXI_SG interface."]
            #[inline(always)]
            #[must_use]
            pub fn sg_user(&mut self) -> SG_USER_W<8> {
                SG_USER_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Scatter/Gather User and Cache\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sg_ctl](index.html) module"]
        pub struct SG_CTL_SPEC;
        impl crate::RegisterSpec for SG_CTL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [sg_ctl::R](R) reader structure"]
        impl crate::Readable for SG_CTL_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [sg_ctl::W](W) writer structure"]
        impl crate::Writable for SG_CTL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets sg_ctl to value 0"]
        impl crate::Resettable for SG_CTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_dmacr (rw) register accessor: an alias for `Reg<S2MM_DMACR_SPEC>`"]
    pub type S2MM_DMACR = crate::Reg<s2mm_dmacr::S2MM_DMACR_SPEC>;
    #[doc = "S2MM DMA Control register"]
    pub mod s2mm_dmacr {
        #[doc = "Register `s2mm_dmacr` reader"]
        pub struct R(crate::R<S2MM_DMACR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_DMACR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_DMACR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_DMACR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_dmacr` writer"]
        pub struct W(crate::W<S2MM_DMACR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_DMACR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_DMACR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_DMACR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `run_stop` reader - Run / Stop control for controlling running and stopping of the DMA channel."]
        pub type RUN_STOP_R = crate::BitReader<RUN_STOP_A>;
        #[doc = "Run / Stop control for controlling running and stopping of the DMA channel.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RUN_STOP_A {
            #[doc = "0: `0`"]
            STOP = 0,
            #[doc = "1: `1`"]
            RUN = 1,
        }
        impl From<RUN_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: RUN_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RUN_STOP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RUN_STOP_A {
                match self.bits {
                    false => RUN_STOP_A::STOP,
                    true => RUN_STOP_A::RUN,
                }
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == RUN_STOP_A::STOP
            }
            #[doc = "Checks if the value of the field is `RUN`"]
            #[inline(always)]
            pub fn is_run(&self) -> bool {
                *self == RUN_STOP_A::RUN
            }
        }
        #[doc = "Field `run_stop` writer - Run / Stop control for controlling running and stopping of the DMA channel."]
        pub type RUN_STOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMACR_SPEC, RUN_STOP_A, O>;
        impl<'a, const O: u8> RUN_STOP_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(RUN_STOP_A::STOP)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn run(self) -> &'a mut W {
                self.variant(RUN_STOP_A::RUN)
            }
        }
        #[doc = "Field `reset` reader - Soft reset for resetting the AXI DMA core"]
        pub type RESET_R = crate::BitReader<RESET_A>;
        #[doc = "Soft reset for resetting the AXI DMA core\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RESET_A {
            #[doc = "0: `0`"]
            NORMAL = 0,
            #[doc = "1: `1`"]
            RESET = 1,
        }
        impl From<RESET_A> for bool {
            #[inline(always)]
            fn from(variant: RESET_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RESET_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RESET_A {
                match self.bits {
                    false => RESET_A::NORMAL,
                    true => RESET_A::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == RESET_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == RESET_A::RESET
            }
        }
        #[doc = "Field `reset` writer - Soft reset for resetting the AXI DMA core"]
        pub type RESET_W<'a, const O: u8> = crate::BitWriter<'a, u32, S2MM_DMACR_SPEC, RESET_A, O>;
        impl<'a, const O: u8> RESET_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(RESET_A::NORMAL)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RESET_A::RESET)
            }
        }
        #[doc = "Field `keyhole` reader - Keyhole Read"]
        pub type KEYHOLE_R = crate::BitReader<KEYHOLE_A>;
        #[doc = "Keyhole Read\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum KEYHOLE_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<KEYHOLE_A> for bool {
            #[inline(always)]
            fn from(variant: KEYHOLE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl KEYHOLE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> KEYHOLE_A {
                match self.bits {
                    false => KEYHOLE_A::DISABLE,
                    true => KEYHOLE_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == KEYHOLE_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == KEYHOLE_A::ENABLE
            }
        }
        #[doc = "Field `keyhole` writer - Keyhole Read"]
        pub type KEYHOLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMACR_SPEC, KEYHOLE_A, O>;
        impl<'a, const O: u8> KEYHOLE_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(KEYHOLE_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(KEYHOLE_A::ENABLE)
            }
        }
        #[doc = "Field `cyclic_buffer_descriptor` reader - When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention"]
        pub type CYCLIC_BUFFER_DESCRIPTOR_R = crate::BitReader<CYCLIC_BUFFER_DESCRIPTOR_A>;
        #[doc = "When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CYCLIC_BUFFER_DESCRIPTOR_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<CYCLIC_BUFFER_DESCRIPTOR_A> for bool {
            #[inline(always)]
            fn from(variant: CYCLIC_BUFFER_DESCRIPTOR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CYCLIC_BUFFER_DESCRIPTOR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CYCLIC_BUFFER_DESCRIPTOR_A {
                match self.bits {
                    false => CYCLIC_BUFFER_DESCRIPTOR_A::DISABLE,
                    true => CYCLIC_BUFFER_DESCRIPTOR_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == CYCLIC_BUFFER_DESCRIPTOR_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == CYCLIC_BUFFER_DESCRIPTOR_A::ENABLE
            }
        }
        #[doc = "Field `cyclic_buffer_descriptor` writer - When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention"]
        pub type CYCLIC_BUFFER_DESCRIPTOR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMACR_SPEC, CYCLIC_BUFFER_DESCRIPTOR_A, O>;
        impl<'a, const O: u8> CYCLIC_BUFFER_DESCRIPTOR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(CYCLIC_BUFFER_DESCRIPTOR_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(CYCLIC_BUFFER_DESCRIPTOR_A::ENABLE)
            }
        }
        #[doc = "Field `ioc_irq_en` reader - Interrupt on Complete (IOC) Interrupt Enable"]
        pub type IOC_IRQ_EN_R = crate::BitReader<IOC_IRQ_EN_A>;
        #[doc = "Interrupt on Complete (IOC) Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IOC_IRQ_EN_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<IOC_IRQ_EN_A> for bool {
            #[inline(always)]
            fn from(variant: IOC_IRQ_EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IOC_IRQ_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IOC_IRQ_EN_A {
                match self.bits {
                    false => IOC_IRQ_EN_A::DISABLE,
                    true => IOC_IRQ_EN_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == IOC_IRQ_EN_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == IOC_IRQ_EN_A::ENABLE
            }
        }
        #[doc = "Field `ioc_irq_en` writer - Interrupt on Complete (IOC) Interrupt Enable"]
        pub type IOC_IRQ_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMACR_SPEC, IOC_IRQ_EN_A, O>;
        impl<'a, const O: u8> IOC_IRQ_EN_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(IOC_IRQ_EN_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(IOC_IRQ_EN_A::ENABLE)
            }
        }
        #[doc = "Field `dly_irq_en` reader - Interrupt on Delay Timer Interrupt Enable"]
        pub type DLY_IRQ_EN_R = crate::BitReader<DLY_IRQ_EN_A>;
        #[doc = "Interrupt on Delay Timer Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DLY_IRQ_EN_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<DLY_IRQ_EN_A> for bool {
            #[inline(always)]
            fn from(variant: DLY_IRQ_EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DLY_IRQ_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DLY_IRQ_EN_A {
                match self.bits {
                    false => DLY_IRQ_EN_A::DISABLE,
                    true => DLY_IRQ_EN_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == DLY_IRQ_EN_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == DLY_IRQ_EN_A::ENABLE
            }
        }
        #[doc = "Field `dly_irq_en` writer - Interrupt on Delay Timer Interrupt Enable"]
        pub type DLY_IRQ_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMACR_SPEC, DLY_IRQ_EN_A, O>;
        impl<'a, const O: u8> DLY_IRQ_EN_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(DLY_IRQ_EN_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(DLY_IRQ_EN_A::ENABLE)
            }
        }
        #[doc = "Field `err_irq_en` reader - Interrupt on Error Interrupt Enable"]
        pub type ERR_IRQ_EN_R = crate::BitReader<ERR_IRQ_EN_A>;
        #[doc = "Interrupt on Error Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERR_IRQ_EN_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<ERR_IRQ_EN_A> for bool {
            #[inline(always)]
            fn from(variant: ERR_IRQ_EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERR_IRQ_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERR_IRQ_EN_A {
                match self.bits {
                    false => ERR_IRQ_EN_A::DISABLE,
                    true => ERR_IRQ_EN_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == ERR_IRQ_EN_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == ERR_IRQ_EN_A::ENABLE
            }
        }
        #[doc = "Field `err_irq_en` writer - Interrupt on Error Interrupt Enable"]
        pub type ERR_IRQ_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMACR_SPEC, ERR_IRQ_EN_A, O>;
        impl<'a, const O: u8> ERR_IRQ_EN_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(ERR_IRQ_EN_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(ERR_IRQ_EN_A::ENABLE)
            }
        }
        #[doc = "Field `irq_threshold` reader - Interrupt Threshold"]
        pub type IRQ_THRESHOLD_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `irq_threshold` writer - Interrupt Threshold"]
        pub type IRQ_THRESHOLD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_DMACR_SPEC, u8, u8, 8, O>;
        #[doc = "Field `irq_delay` reader - Interrupt Delay Time Out"]
        pub type IRQ_DELAY_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `irq_delay` writer - Interrupt Delay Time Out"]
        pub type IRQ_DELAY_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_DMACR_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bit 0 - Run / Stop control for controlling running and stopping of the DMA channel."]
            #[inline(always)]
            pub fn run_stop(&self) -> RUN_STOP_R {
                RUN_STOP_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - Soft reset for resetting the AXI DMA core"]
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Keyhole Read"]
            #[inline(always)]
            pub fn keyhole(&self) -> KEYHOLE_R {
                KEYHOLE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention"]
            #[inline(always)]
            pub fn cyclic_buffer_descriptor(&self) -> CYCLIC_BUFFER_DESCRIPTOR_R {
                CYCLIC_BUFFER_DESCRIPTOR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 12 - Interrupt on Complete (IOC) Interrupt Enable"]
            #[inline(always)]
            pub fn ioc_irq_en(&self) -> IOC_IRQ_EN_R {
                IOC_IRQ_EN_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Interrupt on Delay Timer Interrupt Enable"]
            #[inline(always)]
            pub fn dly_irq_en(&self) -> DLY_IRQ_EN_R {
                DLY_IRQ_EN_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Interrupt on Error Interrupt Enable"]
            #[inline(always)]
            pub fn err_irq_en(&self) -> ERR_IRQ_EN_R {
                ERR_IRQ_EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 16:23 - Interrupt Threshold"]
            #[inline(always)]
            pub fn irq_threshold(&self) -> IRQ_THRESHOLD_R {
                IRQ_THRESHOLD_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - Interrupt Delay Time Out"]
            #[inline(always)]
            pub fn irq_delay(&self) -> IRQ_DELAY_R {
                IRQ_DELAY_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Run / Stop control for controlling running and stopping of the DMA channel."]
            #[inline(always)]
            #[must_use]
            pub fn run_stop(&mut self) -> RUN_STOP_W<0> {
                RUN_STOP_W::new(self)
            }
            #[doc = "Bit 2 - Soft reset for resetting the AXI DMA core"]
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<2> {
                RESET_W::new(self)
            }
            #[doc = "Bit 3 - Keyhole Read"]
            #[inline(always)]
            #[must_use]
            pub fn keyhole(&mut self) -> KEYHOLE_W<3> {
                KEYHOLE_W::new(self)
            }
            #[doc = "Bit 4 - When set to 1, the DMA operates in Cyclic Buffer Descriptor (BD) mode without any user intervention"]
            #[inline(always)]
            #[must_use]
            pub fn cyclic_buffer_descriptor(&mut self) -> CYCLIC_BUFFER_DESCRIPTOR_W<4> {
                CYCLIC_BUFFER_DESCRIPTOR_W::new(self)
            }
            #[doc = "Bit 12 - Interrupt on Complete (IOC) Interrupt Enable"]
            #[inline(always)]
            #[must_use]
            pub fn ioc_irq_en(&mut self) -> IOC_IRQ_EN_W<12> {
                IOC_IRQ_EN_W::new(self)
            }
            #[doc = "Bit 13 - Interrupt on Delay Timer Interrupt Enable"]
            #[inline(always)]
            #[must_use]
            pub fn dly_irq_en(&mut self) -> DLY_IRQ_EN_W<13> {
                DLY_IRQ_EN_W::new(self)
            }
            #[doc = "Bit 14 - Interrupt on Error Interrupt Enable"]
            #[inline(always)]
            #[must_use]
            pub fn err_irq_en(&mut self) -> ERR_IRQ_EN_W<14> {
                ERR_IRQ_EN_W::new(self)
            }
            #[doc = "Bits 16:23 - Interrupt Threshold"]
            #[inline(always)]
            #[must_use]
            pub fn irq_threshold(&mut self) -> IRQ_THRESHOLD_W<16> {
                IRQ_THRESHOLD_W::new(self)
            }
            #[doc = "Bits 24:31 - Interrupt Delay Time Out"]
            #[inline(always)]
            #[must_use]
            pub fn irq_delay(&mut self) -> IRQ_DELAY_W<24> {
                IRQ_DELAY_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM DMA Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_dmacr](index.html) module"]
        pub struct S2MM_DMACR_SPEC;
        impl crate::RegisterSpec for S2MM_DMACR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_dmacr::R](R) reader structure"]
        impl crate::Readable for S2MM_DMACR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_dmacr::W](W) writer structure"]
        impl crate::Writable for S2MM_DMACR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_dmacr to value 0"]
        impl crate::Resettable for S2MM_DMACR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_dmasr (rw) register accessor: an alias for `Reg<S2MM_DMASR_SPEC>`"]
    pub type S2MM_DMASR = crate::Reg<s2mm_dmasr::S2MM_DMASR_SPEC>;
    #[doc = "S2MM DMA Status register"]
    pub mod s2mm_dmasr {
        #[doc = "Register `s2mm_dmasr` reader"]
        pub struct R(crate::R<S2MM_DMASR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_DMASR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_DMASR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_DMASR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_dmasr` writer"]
        pub struct W(crate::W<S2MM_DMASR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_DMASR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_DMASR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_DMASR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `halted` reader - DMA Channel Halted. Indicates the run/stop state of the DMA channel."]
        pub type HALTED_R = crate::BitReader<HALTED_A>;
        #[doc = "DMA Channel Halted. Indicates the run/stop state of the DMA channel.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HALTED_A {
            #[doc = "0: `0`"]
            RUNNING = 0,
            #[doc = "1: `1`"]
            HALTED = 1,
        }
        impl From<HALTED_A> for bool {
            #[inline(always)]
            fn from(variant: HALTED_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HALTED_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HALTED_A {
                match self.bits {
                    false => HALTED_A::RUNNING,
                    true => HALTED_A::HALTED,
                }
            }
            #[doc = "Checks if the value of the field is `RUNNING`"]
            #[inline(always)]
            pub fn is_running(&self) -> bool {
                *self == HALTED_A::RUNNING
            }
            #[doc = "Checks if the value of the field is `HALTED`"]
            #[inline(always)]
            pub fn is_halted(&self) -> bool {
                *self == HALTED_A::HALTED
            }
        }
        #[doc = "Field `halted` writer - DMA Channel Halted. Indicates the run/stop state of the DMA channel."]
        pub type HALTED_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, HALTED_A, O>;
        impl<'a, const O: u8> HALTED_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn running(self) -> &'a mut W {
                self.variant(HALTED_A::RUNNING)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn halted(self) -> &'a mut W {
                self.variant(HALTED_A::HALTED)
            }
        }
        #[doc = "Field `idle` reader - DMA Channel Idle. Indicates the state of AXI DMA operations."]
        pub type IDLE_R = crate::BitReader<IDLE_A>;
        #[doc = "DMA Channel Idle. Indicates the state of AXI DMA operations.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IDLE_A {
            #[doc = "0: `0`"]
            NOT_IDLE = 0,
            #[doc = "1: `1`"]
            IDLE = 1,
        }
        impl From<IDLE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IDLE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IDLE_A {
                match self.bits {
                    false => IDLE_A::NOT_IDLE,
                    true => IDLE_A::IDLE,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_IDLE`"]
            #[inline(always)]
            pub fn is_not_idle(&self) -> bool {
                *self == IDLE_A::NOT_IDLE
            }
            #[doc = "Checks if the value of the field is `IDLE`"]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == IDLE_A::IDLE
            }
        }
        #[doc = "Field `idle` writer - DMA Channel Idle. Indicates the state of AXI DMA operations."]
        pub type IDLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, IDLE_A, O>;
        impl<'a, const O: u8> IDLE_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn not_idle(self) -> &'a mut W {
                self.variant(IDLE_A::NOT_IDLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn idle(self) -> &'a mut W {
                self.variant(IDLE_A::IDLE)
            }
        }
        #[doc = "Field `sg_incld` reader - Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode."]
        pub type SG_INCLD_R = crate::BitReader<SG_INCLD_A>;
        #[doc = "Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SG_INCLD_A {
            #[doc = "0: `0`"]
            SG_DISABLED = 0,
            #[doc = "1: `1`"]
            SG_ENABLED = 1,
        }
        impl From<SG_INCLD_A> for bool {
            #[inline(always)]
            fn from(variant: SG_INCLD_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SG_INCLD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SG_INCLD_A {
                match self.bits {
                    false => SG_INCLD_A::SG_DISABLED,
                    true => SG_INCLD_A::SG_ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `SG_DISABLED`"]
            #[inline(always)]
            pub fn is_sg_disabled(&self) -> bool {
                *self == SG_INCLD_A::SG_DISABLED
            }
            #[doc = "Checks if the value of the field is `SG_ENABLED`"]
            #[inline(always)]
            pub fn is_sg_enabled(&self) -> bool {
                *self == SG_INCLD_A::SG_ENABLED
            }
        }
        #[doc = "Field `sg_incld` writer - Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode."]
        pub type SG_INCLD_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, SG_INCLD_A, O>;
        impl<'a, const O: u8> SG_INCLD_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn sg_disabled(self) -> &'a mut W {
                self.variant(SG_INCLD_A::SG_DISABLED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn sg_enabled(self) -> &'a mut W {
                self.variant(SG_INCLD_A::SG_ENABLED)
            }
        }
        #[doc = "Field `dma_int_err` reader - DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0."]
        pub type DMA_INT_ERR_R = crate::BitReader<DMA_INT_ERR_A>;
        #[doc = "DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_INT_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_INT_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_INT_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_INT_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_INT_ERR_A {
                match self.bits {
                    false => DMA_INT_ERR_A::NO_ERR,
                    true => DMA_INT_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_INT_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_INT_ERR_A::DETECTED
            }
        }
        #[doc = "Field `dma_int_err` writer - DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0."]
        pub type DMA_INT_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, DMA_INT_ERR_A, O>;
        impl<'a, const O: u8> DMA_INT_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(DMA_INT_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(DMA_INT_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `dma_slv_err` reader - DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
        pub type DMA_SLV_ERR_R = crate::BitReader<DMA_SLV_ERR_A>;
        #[doc = "DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_SLV_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_SLV_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_SLV_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_SLV_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_SLV_ERR_A {
                match self.bits {
                    false => DMA_SLV_ERR_A::NO_ERR,
                    true => DMA_SLV_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_SLV_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_SLV_ERR_A::DETECTED
            }
        }
        #[doc = "Field `dma_slv_err` writer - DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
        pub type DMA_SLV_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, DMA_SLV_ERR_A, O>;
        impl<'a, const O: u8> DMA_SLV_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(DMA_SLV_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(DMA_SLV_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `dma_dec_err` reader - DMA Decode Error. This error occurs if the address request points to an invalid address."]
        pub type DMA_DEC_ERR_R = crate::BitReader<DMA_DEC_ERR_A>;
        #[doc = "DMA Decode Error. This error occurs if the address request points to an invalid address.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_DEC_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_DEC_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_DEC_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_DEC_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_DEC_ERR_A {
                match self.bits {
                    false => DMA_DEC_ERR_A::NO_ERR,
                    true => DMA_DEC_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_DEC_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_DEC_ERR_A::DETECTED
            }
        }
        #[doc = "Field `dma_dec_err` writer - DMA Decode Error. This error occurs if the address request points to an invalid address."]
        pub type DMA_DEC_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, DMA_DEC_ERR_A, O>;
        impl<'a, const O: u8> DMA_DEC_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(DMA_DEC_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(DMA_DEC_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `sg_int_err` reader - Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched."]
        pub type SG_INT_ERR_R = crate::BitReader<SG_INT_ERR_A>;
        #[doc = "Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SG_INT_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<SG_INT_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: SG_INT_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SG_INT_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SG_INT_ERR_A {
                match self.bits {
                    false => SG_INT_ERR_A::NO_ERR,
                    true => SG_INT_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == SG_INT_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == SG_INT_ERR_A::DETECTED
            }
        }
        #[doc = "Field `sg_int_err` writer - Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched."]
        pub type SG_INT_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, SG_INT_ERR_A, O>;
        impl<'a, const O: u8> SG_INT_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(SG_INT_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(SG_INT_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `sg_slv_err` reader - Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error."]
        pub type SG_SLV_ERR_R = crate::BitReader<SG_SLV_ERR_A>;
        #[doc = "Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SG_SLV_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<SG_SLV_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: SG_SLV_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SG_SLV_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SG_SLV_ERR_A {
                match self.bits {
                    false => SG_SLV_ERR_A::NO_ERR,
                    true => SG_SLV_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == SG_SLV_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == SG_SLV_ERR_A::DETECTED
            }
        }
        #[doc = "Field `sg_slv_err` writer - Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error."]
        pub type SG_SLV_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, SG_SLV_ERR_A, O>;
        impl<'a, const O: u8> SG_SLV_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(SG_SLV_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(SG_SLV_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `sg_dec_err` reader - Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address."]
        pub type SG_DEC_ERR_R = crate::BitReader<SG_DEC_ERR_A>;
        #[doc = "Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SG_DEC_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<SG_DEC_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: SG_DEC_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SG_DEC_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SG_DEC_ERR_A {
                match self.bits {
                    false => SG_DEC_ERR_A::NO_ERR,
                    true => SG_DEC_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == SG_DEC_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == SG_DEC_ERR_A::DETECTED
            }
        }
        #[doc = "Field `sg_dec_err` writer - Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address."]
        pub type SG_DEC_ERR_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, SG_DEC_ERR_A, O>;
        impl<'a, const O: u8> SG_DEC_ERR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_err(self) -> &'a mut W {
                self.variant(SG_DEC_ERR_A::NO_ERR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(SG_DEC_ERR_A::DETECTED)
            }
        }
        #[doc = "Field `ioc_irq` reader - Interrupt on Complete (IOC)"]
        pub type IOC_IRQ_R = crate::BitReader<IOC_IRQ_A>;
        #[doc = "Interrupt on Complete (IOC)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IOC_IRQ_A {
            #[doc = "0: `0`"]
            NO_INTR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<IOC_IRQ_A> for bool {
            #[inline(always)]
            fn from(variant: IOC_IRQ_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IOC_IRQ_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IOC_IRQ_A {
                match self.bits {
                    false => IOC_IRQ_A::NO_INTR,
                    true => IOC_IRQ_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTR`"]
            #[inline(always)]
            pub fn is_no_intr(&self) -> bool {
                *self == IOC_IRQ_A::NO_INTR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == IOC_IRQ_A::DETECTED
            }
        }
        #[doc = "Field `ioc_irq` writer - Interrupt on Complete (IOC)"]
        pub type IOC_IRQ_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, IOC_IRQ_A, O>;
        impl<'a, const O: u8> IOC_IRQ_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_intr(self) -> &'a mut W {
                self.variant(IOC_IRQ_A::NO_INTR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(IOC_IRQ_A::DETECTED)
            }
        }
        #[doc = "Field `dly_irq` reader - Interrupt on Delay Timer"]
        pub type DLY_IRQ_R = crate::BitReader<DLY_IRQ_A>;
        #[doc = "Interrupt on Delay Timer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DLY_IRQ_A {
            #[doc = "0: `0`"]
            NO_INTR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DLY_IRQ_A> for bool {
            #[inline(always)]
            fn from(variant: DLY_IRQ_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DLY_IRQ_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DLY_IRQ_A {
                match self.bits {
                    false => DLY_IRQ_A::NO_INTR,
                    true => DLY_IRQ_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTR`"]
            #[inline(always)]
            pub fn is_no_intr(&self) -> bool {
                *self == DLY_IRQ_A::NO_INTR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DLY_IRQ_A::DETECTED
            }
        }
        #[doc = "Field `dly_irq` writer - Interrupt on Delay Timer"]
        pub type DLY_IRQ_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, DLY_IRQ_A, O>;
        impl<'a, const O: u8> DLY_IRQ_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_intr(self) -> &'a mut W {
                self.variant(DLY_IRQ_A::NO_INTR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(DLY_IRQ_A::DETECTED)
            }
        }
        #[doc = "Field `err_irq` reader - Interrupt on Error"]
        pub type ERR_IRQ_R = crate::BitReader<ERR_IRQ_A>;
        #[doc = "Interrupt on Error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERR_IRQ_A {
            #[doc = "0: `0`"]
            NO_INTR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<ERR_IRQ_A> for bool {
            #[inline(always)]
            fn from(variant: ERR_IRQ_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERR_IRQ_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERR_IRQ_A {
                match self.bits {
                    false => ERR_IRQ_A::NO_INTR,
                    true => ERR_IRQ_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTR`"]
            #[inline(always)]
            pub fn is_no_intr(&self) -> bool {
                *self == ERR_IRQ_A::NO_INTR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == ERR_IRQ_A::DETECTED
            }
        }
        #[doc = "Field `err_irq` writer - Interrupt on Error"]
        pub type ERR_IRQ_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_DMASR_SPEC, ERR_IRQ_A, O>;
        impl<'a, const O: u8> ERR_IRQ_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_intr(self) -> &'a mut W {
                self.variant(ERR_IRQ_A::NO_INTR)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn detected(self) -> &'a mut W {
                self.variant(ERR_IRQ_A::DETECTED)
            }
        }
        #[doc = "Field `irq_threshold_sts` reader - Interrupt Threshold Status. Indicates current interrupt threshold value."]
        pub type IRQ_THRESHOLD_STS_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `irq_threshold_sts` writer - Interrupt Threshold Status. Indicates current interrupt threshold value."]
        pub type IRQ_THRESHOLD_STS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_DMASR_SPEC, u8, u8, 8, O>;
        #[doc = "Field `irq_delay_sts` reader - Interrupt Delay Time Status. Indicates current interrupt delay time value."]
        pub type IRQ_DELAY_STS_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `irq_delay_sts` writer - Interrupt Delay Time Status. Indicates current interrupt delay time value."]
        pub type IRQ_DELAY_STS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_DMASR_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bit 0 - DMA Channel Halted. Indicates the run/stop state of the DMA channel."]
            #[inline(always)]
            pub fn halted(&self) -> HALTED_R {
                HALTED_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - DMA Channel Idle. Indicates the state of AXI DMA operations."]
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode."]
            #[inline(always)]
            pub fn sg_incld(&self) -> SG_INCLD_R {
                SG_INCLD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0."]
            #[inline(always)]
            pub fn dma_int_err(&self) -> DMA_INT_ERR_R {
                DMA_INT_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
            #[inline(always)]
            pub fn dma_slv_err(&self) -> DMA_SLV_ERR_R {
                DMA_SLV_ERR_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - DMA Decode Error. This error occurs if the address request points to an invalid address."]
            #[inline(always)]
            pub fn dma_dec_err(&self) -> DMA_DEC_ERR_R {
                DMA_DEC_ERR_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched."]
            #[inline(always)]
            pub fn sg_int_err(&self) -> SG_INT_ERR_R {
                SG_INT_ERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error."]
            #[inline(always)]
            pub fn sg_slv_err(&self) -> SG_SLV_ERR_R {
                SG_SLV_ERR_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address."]
            #[inline(always)]
            pub fn sg_dec_err(&self) -> SG_DEC_ERR_R {
                SG_DEC_ERR_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 12 - Interrupt on Complete (IOC)"]
            #[inline(always)]
            pub fn ioc_irq(&self) -> IOC_IRQ_R {
                IOC_IRQ_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Interrupt on Delay Timer"]
            #[inline(always)]
            pub fn dly_irq(&self) -> DLY_IRQ_R {
                DLY_IRQ_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Interrupt on Error"]
            #[inline(always)]
            pub fn err_irq(&self) -> ERR_IRQ_R {
                ERR_IRQ_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 16:23 - Interrupt Threshold Status. Indicates current interrupt threshold value."]
            #[inline(always)]
            pub fn irq_threshold_sts(&self) -> IRQ_THRESHOLD_STS_R {
                IRQ_THRESHOLD_STS_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - Interrupt Delay Time Status. Indicates current interrupt delay time value."]
            #[inline(always)]
            pub fn irq_delay_sts(&self) -> IRQ_DELAY_STS_R {
                IRQ_DELAY_STS_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - DMA Channel Halted. Indicates the run/stop state of the DMA channel."]
            #[inline(always)]
            #[must_use]
            pub fn halted(&mut self) -> HALTED_W<0> {
                HALTED_W::new(self)
            }
            #[doc = "Bit 1 - DMA Channel Idle. Indicates the state of AXI DMA operations."]
            #[inline(always)]
            #[must_use]
            pub fn idle(&mut self) -> IDLE_W<1> {
                IDLE_W::new(self)
            }
            #[doc = "Bit 3 - Scatter Gather Engine Included. DMASR.SGIncld = 1 indicates the Scatter Gather engine is included and the AXI DMA is configured for Scatter Gather mode."]
            #[inline(always)]
            #[must_use]
            pub fn sg_incld(&mut self) -> SG_INCLD_W<3> {
                SG_INCLD_W::new(self)
            }
            #[doc = "Bit 4 - DMA Internal Error. Internal error occurs if the buffer length specified in the fetched descriptor is set to 0."]
            #[inline(always)]
            #[must_use]
            pub fn dma_int_err(&mut self) -> DMA_INT_ERR_W<4> {
                DMA_INT_ERR_W::new(self)
            }
            #[doc = "Bit 5 - DMA Slave Error. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
            #[inline(always)]
            #[must_use]
            pub fn dma_slv_err(&mut self) -> DMA_SLV_ERR_W<5> {
                DMA_SLV_ERR_W::new(self)
            }
            #[doc = "Bit 6 - DMA Decode Error. This error occurs if the address request points to an invalid address."]
            #[inline(always)]
            #[must_use]
            pub fn dma_dec_err(&mut self) -> DMA_DEC_ERR_W<6> {
                DMA_DEC_ERR_W::new(self)
            }
            #[doc = "Bit 8 - Scatter Gather Internal Error. This error occurs if a descriptor with the Complete bit already set is fetched."]
            #[inline(always)]
            #[must_use]
            pub fn sg_int_err(&mut self) -> SG_INT_ERR_W<8> {
                SG_INT_ERR_W::new(self)
            }
            #[doc = "Bit 9 - Scatter Gather Slave Error. This error occurs if the slave read from on the Memory Map interface issues a Slave error."]
            #[inline(always)]
            #[must_use]
            pub fn sg_slv_err(&mut self) -> SG_SLV_ERR_W<9> {
                SG_SLV_ERR_W::new(self)
            }
            #[doc = "Bit 10 - Scatter Gather Decode Error. This error occurs if CURDESC_PTR and/or NXTDESC_PTR points to an invalid address."]
            #[inline(always)]
            #[must_use]
            pub fn sg_dec_err(&mut self) -> SG_DEC_ERR_W<10> {
                SG_DEC_ERR_W::new(self)
            }
            #[doc = "Bit 12 - Interrupt on Complete (IOC)"]
            #[inline(always)]
            #[must_use]
            pub fn ioc_irq(&mut self) -> IOC_IRQ_W<12> {
                IOC_IRQ_W::new(self)
            }
            #[doc = "Bit 13 - Interrupt on Delay Timer"]
            #[inline(always)]
            #[must_use]
            pub fn dly_irq(&mut self) -> DLY_IRQ_W<13> {
                DLY_IRQ_W::new(self)
            }
            #[doc = "Bit 14 - Interrupt on Error"]
            #[inline(always)]
            #[must_use]
            pub fn err_irq(&mut self) -> ERR_IRQ_W<14> {
                ERR_IRQ_W::new(self)
            }
            #[doc = "Bits 16:23 - Interrupt Threshold Status. Indicates current interrupt threshold value."]
            #[inline(always)]
            #[must_use]
            pub fn irq_threshold_sts(&mut self) -> IRQ_THRESHOLD_STS_W<16> {
                IRQ_THRESHOLD_STS_W::new(self)
            }
            #[doc = "Bits 24:31 - Interrupt Delay Time Status. Indicates current interrupt delay time value."]
            #[inline(always)]
            #[must_use]
            pub fn irq_delay_sts(&mut self) -> IRQ_DELAY_STS_W<24> {
                IRQ_DELAY_STS_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM DMA Status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_dmasr](index.html) module"]
        pub struct S2MM_DMASR_SPEC;
        impl crate::RegisterSpec for S2MM_DMASR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_dmasr::R](R) reader structure"]
        impl crate::Readable for S2MM_DMASR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_dmasr::W](W) writer structure"]
        impl crate::Writable for S2MM_DMASR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_dmasr to value 0"]
        impl crate::Resettable for S2MM_DMASR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_curdesc (rw) register accessor: an alias for `Reg<S2MM_CURDESC_SPEC>`"]
    pub type S2MM_CURDESC = crate::Reg<s2mm_curdesc::S2MM_CURDESC_SPEC>;
    #[doc = "S2MM Current Descriptor Pointer. Lower 32 address bits."]
    pub mod s2mm_curdesc {
        #[doc = "Register `s2mm_curdesc` reader"]
        pub struct R(crate::R<S2MM_CURDESC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_CURDESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_CURDESC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_CURDESC_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_curdesc` writer"]
        pub struct W(crate::W<S2MM_CURDESC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_CURDESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_CURDESC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_CURDESC_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `curdesc_ptr` reader - Indicates the pointer of the current Buffer Descriptor being worked on."]
        pub type CURDESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `curdesc_ptr` writer - Indicates the pointer of the current Buffer Descriptor being worked on."]
        pub type CURDESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_CURDESC_SPEC, u32, u32, 26, O>;
        impl R {
            #[doc = "Bits 6:31 - Indicates the pointer of the current Buffer Descriptor being worked on."]
            #[inline(always)]
            pub fn curdesc_ptr(&self) -> CURDESC_PTR_R {
                CURDESC_PTR_R::new((self.bits >> 6) & 0x03ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 6:31 - Indicates the pointer of the current Buffer Descriptor being worked on."]
            #[inline(always)]
            #[must_use]
            pub fn curdesc_ptr(&mut self) -> CURDESC_PTR_W<6> {
                CURDESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM Current Descriptor Pointer. Lower 32 address bits.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_curdesc](index.html) module"]
        pub struct S2MM_CURDESC_SPEC;
        impl crate::RegisterSpec for S2MM_CURDESC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_curdesc::R](R) reader structure"]
        impl crate::Readable for S2MM_CURDESC_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_curdesc::W](W) writer structure"]
        impl crate::Writable for S2MM_CURDESC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_curdesc to value 0"]
        impl crate::Resettable for S2MM_CURDESC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_curdesc_msb (rw) register accessor: an alias for `Reg<S2MM_CURDESC_MSB_SPEC>`"]
    pub type S2MM_CURDESC_MSB = crate::Reg<s2mm_curdesc_msb::S2MM_CURDESC_MSB_SPEC>;
    #[doc = "S2MM Current Descriptor Pointer. Upper 32 address bits."]
    pub mod s2mm_curdesc_msb {
        #[doc = "Register `s2mm_curdesc_msb` reader"]
        pub struct R(crate::R<S2MM_CURDESC_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_CURDESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_CURDESC_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_CURDESC_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_curdesc_msb` writer"]
        pub struct W(crate::W<S2MM_CURDESC_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_CURDESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_CURDESC_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_CURDESC_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `curdesc_ptr` reader - Indicates the pointer of the current Buffer Descriptor being worked on."]
        pub type CURDESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `curdesc_ptr` writer - Indicates the pointer of the current Buffer Descriptor being worked on."]
        pub type CURDESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_CURDESC_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the pointer of the current Buffer Descriptor being worked on."]
            #[inline(always)]
            pub fn curdesc_ptr(&self) -> CURDESC_PTR_R {
                CURDESC_PTR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the pointer of the current Buffer Descriptor being worked on."]
            #[inline(always)]
            #[must_use]
            pub fn curdesc_ptr(&mut self) -> CURDESC_PTR_W<0> {
                CURDESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM Current Descriptor Pointer. Upper 32 address bits.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_curdesc_msb](index.html) module"]
        pub struct S2MM_CURDESC_MSB_SPEC;
        impl crate::RegisterSpec for S2MM_CURDESC_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_curdesc_msb::R](R) reader structure"]
        impl crate::Readable for S2MM_CURDESC_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_curdesc_msb::W](W) writer structure"]
        impl crate::Writable for S2MM_CURDESC_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_curdesc_msb to value 0"]
        impl crate::Resettable for S2MM_CURDESC_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_taildesc (rw) register accessor: an alias for `Reg<S2MM_TAILDESC_SPEC>`"]
    pub type S2MM_TAILDESC = crate::Reg<s2mm_taildesc::S2MM_TAILDESC_SPEC>;
    #[doc = "S2MM Tail Descriptor Pointer. Lower 32 address bits."]
    pub mod s2mm_taildesc {
        #[doc = "Register `s2mm_taildesc` reader"]
        pub struct R(crate::R<S2MM_TAILDESC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_TAILDESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_TAILDESC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_TAILDESC_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_taildesc` writer"]
        pub struct W(crate::W<S2MM_TAILDESC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_TAILDESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_TAILDESC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_TAILDESC_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `taildesc_ptr` reader - Indicates the pause pointer in a descriptor chain."]
        pub type TAILDESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `taildesc_ptr` writer - Indicates the pause pointer in a descriptor chain."]
        pub type TAILDESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_TAILDESC_SPEC, u32, u32, 26, O>;
        impl R {
            #[doc = "Bits 6:31 - Indicates the pause pointer in a descriptor chain."]
            #[inline(always)]
            pub fn taildesc_ptr(&self) -> TAILDESC_PTR_R {
                TAILDESC_PTR_R::new((self.bits >> 6) & 0x03ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 6:31 - Indicates the pause pointer in a descriptor chain."]
            #[inline(always)]
            #[must_use]
            pub fn taildesc_ptr(&mut self) -> TAILDESC_PTR_W<6> {
                TAILDESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM Tail Descriptor Pointer. Lower 32 address bits.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_taildesc](index.html) module"]
        pub struct S2MM_TAILDESC_SPEC;
        impl crate::RegisterSpec for S2MM_TAILDESC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_taildesc::R](R) reader structure"]
        impl crate::Readable for S2MM_TAILDESC_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_taildesc::W](W) writer structure"]
        impl crate::Writable for S2MM_TAILDESC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_taildesc to value 0"]
        impl crate::Resettable for S2MM_TAILDESC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_taildesc_msb (rw) register accessor: an alias for `Reg<S2MM_TAILDESC_MSB_SPEC>`"]
    pub type S2MM_TAILDESC_MSB = crate::Reg<s2mm_taildesc_msb::S2MM_TAILDESC_MSB_SPEC>;
    #[doc = "S2MM Tail Descriptor Pointer. Upper 32 address bits."]
    pub mod s2mm_taildesc_msb {
        #[doc = "Register `s2mm_taildesc_msb` reader"]
        pub struct R(crate::R<S2MM_TAILDESC_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_TAILDESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_TAILDESC_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_TAILDESC_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_taildesc_msb` writer"]
        pub struct W(crate::W<S2MM_TAILDESC_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_TAILDESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_TAILDESC_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_TAILDESC_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `taildesc_ptr` reader - Indicates the pause pointer in a descriptor chain."]
        pub type TAILDESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `taildesc_ptr` writer - Indicates the pause pointer in a descriptor chain."]
        pub type TAILDESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_TAILDESC_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the pause pointer in a descriptor chain."]
            #[inline(always)]
            pub fn taildesc_ptr(&self) -> TAILDESC_PTR_R {
                TAILDESC_PTR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the pause pointer in a descriptor chain."]
            #[inline(always)]
            #[must_use]
            pub fn taildesc_ptr(&mut self) -> TAILDESC_PTR_W<0> {
                TAILDESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM Tail Descriptor Pointer. Upper 32 address bits.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_taildesc_msb](index.html) module"]
        pub struct S2MM_TAILDESC_MSB_SPEC;
        impl crate::RegisterSpec for S2MM_TAILDESC_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_taildesc_msb::R](R) reader structure"]
        impl crate::Readable for S2MM_TAILDESC_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_taildesc_msb::W](W) writer structure"]
        impl crate::Writable for S2MM_TAILDESC_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_taildesc_msb to value 0"]
        impl crate::Resettable for S2MM_TAILDESC_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_da (rw) register accessor: an alias for `Reg<S2MM_DA_SPEC>`"]
    pub type S2MM_DA = crate::Reg<s2mm_da::S2MM_DA_SPEC>;
    #[doc = "S2MM Destination Address. Lower 32 bit address"]
    pub mod s2mm_da {
        #[doc = "Register `s2mm_da` reader"]
        pub struct R(crate::R<S2MM_DA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_DA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_DA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_DA_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_da` writer"]
        pub struct W(crate::W<S2MM_DA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_DA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_DA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_DA_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `dst_addr` reader - Indicates the destination address the AXI DMA writes to transfer data from AXI4-Stream on S2MM Channel."]
        pub type DST_ADDR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `dst_addr` writer - Indicates the destination address the AXI DMA writes to transfer data from AXI4-Stream on S2MM Channel."]
        pub type DST_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_DA_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the destination address the AXI DMA writes to transfer data from AXI4-Stream on S2MM Channel."]
            #[inline(always)]
            pub fn dst_addr(&self) -> DST_ADDR_R {
                DST_ADDR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the destination address the AXI DMA writes to transfer data from AXI4-Stream on S2MM Channel."]
            #[inline(always)]
            #[must_use]
            pub fn dst_addr(&mut self) -> DST_ADDR_W<0> {
                DST_ADDR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM Destination Address. Lower 32 bit address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_da](index.html) module"]
        pub struct S2MM_DA_SPEC;
        impl crate::RegisterSpec for S2MM_DA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_da::R](R) reader structure"]
        impl crate::Readable for S2MM_DA_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_da::W](W) writer structure"]
        impl crate::Writable for S2MM_DA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_da to value 0"]
        impl crate::Resettable for S2MM_DA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_da_msb (rw) register accessor: an alias for `Reg<S2MM_DA_MSB_SPEC>`"]
    pub type S2MM_DA_MSB = crate::Reg<s2mm_da_msb::S2MM_DA_MSB_SPEC>;
    #[doc = "S2MM Destination Address. Upper 32 bit address."]
    pub mod s2mm_da_msb {
        #[doc = "Register `s2mm_da_msb` reader"]
        pub struct R(crate::R<S2MM_DA_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_DA_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_DA_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_DA_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_da_msb` writer"]
        pub struct W(crate::W<S2MM_DA_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_DA_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_DA_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_DA_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `dst_addr` reader - Indicates the MSB 32 bits of the destination address the AXI DMA writes to transfer data from AXI4-Stream on the S2MM Channel."]
        pub type DST_ADDR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `dst_addr` writer - Indicates the MSB 32 bits of the destination address the AXI DMA writes to transfer data from AXI4-Stream on the S2MM Channel."]
        pub type DST_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, S2MM_DA_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the MSB 32 bits of the destination address the AXI DMA writes to transfer data from AXI4-Stream on the S2MM Channel."]
            #[inline(always)]
            pub fn dst_addr(&self) -> DST_ADDR_R {
                DST_ADDR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the MSB 32 bits of the destination address the AXI DMA writes to transfer data from AXI4-Stream on the S2MM Channel."]
            #[inline(always)]
            #[must_use]
            pub fn dst_addr(&mut self) -> DST_ADDR_W<0> {
                DST_ADDR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM Destination Address. Upper 32 bit address.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_da_msb](index.html) module"]
        pub struct S2MM_DA_MSB_SPEC;
        impl crate::RegisterSpec for S2MM_DA_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_da_msb::R](R) reader structure"]
        impl crate::Readable for S2MM_DA_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_da_msb::W](W) writer structure"]
        impl crate::Writable for S2MM_DA_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_da_msb to value 0"]
        impl crate::Resettable for S2MM_DA_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "s2mm_length (rw) register accessor: an alias for `Reg<S2MM_LENGTH_SPEC>`"]
    pub type S2MM_LENGTH = crate::Reg<s2mm_length::S2MM_LENGTH_SPEC>;
    #[doc = "S2MM Buffer Length (Bytes)"]
    pub mod s2mm_length {
        #[doc = "Register `s2mm_length` reader"]
        pub struct R(crate::R<S2MM_LENGTH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<S2MM_LENGTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<S2MM_LENGTH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<S2MM_LENGTH_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `s2mm_length` writer"]
        pub struct W(crate::W<S2MM_LENGTH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<S2MM_LENGTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<S2MM_LENGTH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<S2MM_LENGTH_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `ctl_lt_initialize_to_tx` reader - "]
        pub type CTL_LT_INITIALIZE_TO_TX_R = crate::BitReader<CTL_LT_INITIALIZE_TO_TX_A>;
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTL_LT_INITIALIZE_TO_TX_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<CTL_LT_INITIALIZE_TO_TX_A> for bool {
            #[inline(always)]
            fn from(variant: CTL_LT_INITIALIZE_TO_TX_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CTL_LT_INITIALIZE_TO_TX_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CTL_LT_INITIALIZE_TO_TX_A {
                match self.bits {
                    false => CTL_LT_INITIALIZE_TO_TX_A::DISABLE,
                    true => CTL_LT_INITIALIZE_TO_TX_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == CTL_LT_INITIALIZE_TO_TX_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == CTL_LT_INITIALIZE_TO_TX_A::ENABLE
            }
        }
        #[doc = "Field `ctl_lt_initialize_to_tx` writer - "]
        pub type CTL_LT_INITIALIZE_TO_TX_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, S2MM_LENGTH_SPEC, CTL_LT_INITIALIZE_TO_TX_A, O>;
        impl<'a, const O: u8> CTL_LT_INITIALIZE_TO_TX_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(CTL_LT_INITIALIZE_TO_TX_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(CTL_LT_INITIALIZE_TO_TX_A::ENABLE)
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn ctl_lt_initialize_to_tx(&self) -> CTL_LT_INITIALIZE_TO_TX_R {
                CTL_LT_INITIALIZE_TO_TX_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn ctl_lt_initialize_to_tx(&mut self) -> CTL_LT_INITIALIZE_TO_TX_W<0> {
                CTL_LT_INITIALIZE_TO_TX_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "S2MM Buffer Length (Bytes)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [s2mm_length](index.html) module"]
        pub struct S2MM_LENGTH_SPEC;
        impl crate::RegisterSpec for S2MM_LENGTH_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [s2mm_length::R](R) reader structure"]
        impl crate::Readable for S2MM_LENGTH_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [s2mm_length::W](W) writer structure"]
        impl crate::Writable for S2MM_LENGTH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets s2mm_length to value 0"]
        impl crate::Resettable for S2MM_LENGTH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Scatter Gather Descriptor"]
pub struct MM2S_SG_DESC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MM2S_SG_DESC {}
impl MM2S_SG_DESC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mm2s_sg_desc::RegisterBlock = 0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mm2s_sg_desc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for MM2S_SG_DESC {
    type Target = mm2s_sg_desc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MM2S_SG_DESC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MM2S_SG_DESC").finish()
    }
}
#[doc = "Scatter Gather Descriptor"]
pub mod mm2s_sg_desc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Next Descriptor Pointer"]
        pub nxt_desc: NXT_DESC,
        #[doc = "0x04 - Upper 32 bits of Next Descriptor Pointer"]
        pub nxt_desc_msb: NXT_DESC_MSB,
        #[doc = "0x08 - Buffer Address"]
        pub buf_addr: BUF_ADDR,
        #[doc = "0x0c - Upper 32 bits of Buffer Address"]
        pub buf_addr_msb: BUF_ADDR_MSB,
        _reserved4: [u8; 0x08],
        #[doc = "0x18 - "]
        pub control: CONTROL,
        #[doc = "0x1c - "]
        pub status: STATUS,
        #[doc = "0x20..0x34 - User Application Field \\[%s\\]"]
        pub app: [APP; 5],
    }
    #[doc = "nxt_desc (rw) register accessor: an alias for `Reg<NXT_DESC_SPEC>`"]
    pub type NXT_DESC = crate::Reg<nxt_desc::NXT_DESC_SPEC>;
    #[doc = "Next Descriptor Pointer"]
    pub mod nxt_desc {
        #[doc = "Register `nxt_desc` reader"]
        pub struct R(crate::R<NXT_DESC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<NXT_DESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<NXT_DESC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<NXT_DESC_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `nxt_desc` writer"]
        pub struct W(crate::W<NXT_DESC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<NXT_DESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<NXT_DESC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<NXT_DESC_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `nxt_desc_ptr` reader - Indicates the lower order pointer pointing to the first word of the next descriptor"]
        pub type NXT_DESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `nxt_desc_ptr` writer - Indicates the lower order pointer pointing to the first word of the next descriptor"]
        pub type NXT_DESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, NXT_DESC_SPEC, u32, u32, 26, O>;
        impl R {
            #[doc = "Bits 6:31 - Indicates the lower order pointer pointing to the first word of the next descriptor"]
            #[inline(always)]
            pub fn nxt_desc_ptr(&self) -> NXT_DESC_PTR_R {
                NXT_DESC_PTR_R::new((self.bits >> 6) & 0x03ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 6:31 - Indicates the lower order pointer pointing to the first word of the next descriptor"]
            #[inline(always)]
            #[must_use]
            pub fn nxt_desc_ptr(&mut self) -> NXT_DESC_PTR_W<6> {
                NXT_DESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Next Descriptor Pointer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nxt_desc](index.html) module"]
        pub struct NXT_DESC_SPEC;
        impl crate::RegisterSpec for NXT_DESC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [nxt_desc::R](R) reader structure"]
        impl crate::Readable for NXT_DESC_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [nxt_desc::W](W) writer structure"]
        impl crate::Writable for NXT_DESC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets nxt_desc to value 0"]
        impl crate::Resettable for NXT_DESC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "nxt_desc_msb (rw) register accessor: an alias for `Reg<NXT_DESC_MSB_SPEC>`"]
    pub type NXT_DESC_MSB = crate::Reg<nxt_desc_msb::NXT_DESC_MSB_SPEC>;
    #[doc = "Upper 32 bits of Next Descriptor Pointer"]
    pub mod nxt_desc_msb {
        #[doc = "Register `nxt_desc_msb` reader"]
        pub struct R(crate::R<NXT_DESC_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<NXT_DESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<NXT_DESC_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<NXT_DESC_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `nxt_desc_msb` writer"]
        pub struct W(crate::W<NXT_DESC_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<NXT_DESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<NXT_DESC_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<NXT_DESC_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `nxt_desc_ptr` reader - Indicates the MSB 32 bits of the pointer pointing to the first word of the next descriptor"]
        pub type NXT_DESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `nxt_desc_ptr` writer - Indicates the MSB 32 bits of the pointer pointing to the first word of the next descriptor"]
        pub type NXT_DESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, NXT_DESC_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the MSB 32 bits of the pointer pointing to the first word of the next descriptor"]
            #[inline(always)]
            pub fn nxt_desc_ptr(&self) -> NXT_DESC_PTR_R {
                NXT_DESC_PTR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the MSB 32 bits of the pointer pointing to the first word of the next descriptor"]
            #[inline(always)]
            #[must_use]
            pub fn nxt_desc_ptr(&mut self) -> NXT_DESC_PTR_W<0> {
                NXT_DESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Upper 32 bits of Next Descriptor Pointer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nxt_desc_msb](index.html) module"]
        pub struct NXT_DESC_MSB_SPEC;
        impl crate::RegisterSpec for NXT_DESC_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [nxt_desc_msb::R](R) reader structure"]
        impl crate::Readable for NXT_DESC_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [nxt_desc_msb::W](W) writer structure"]
        impl crate::Writable for NXT_DESC_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets nxt_desc_msb to value 0"]
        impl crate::Resettable for NXT_DESC_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "buf_addr (rw) register accessor: an alias for `Reg<BUF_ADDR_SPEC>`"]
    pub type BUF_ADDR = crate::Reg<buf_addr::BUF_ADDR_SPEC>;
    #[doc = "Buffer Address"]
    pub mod buf_addr {
        #[doc = "Register `buf_addr` reader"]
        pub struct R(crate::R<BUF_ADDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BUF_ADDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BUF_ADDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BUF_ADDR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `buf_addr` writer"]
        pub struct W(crate::W<BUF_ADDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BUF_ADDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BUF_ADDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BUF_ADDR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `buf_addr` reader - Provides the location of the data to transfer from Memory Map to Stream."]
        pub type BUF_ADDR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `buf_addr` writer - Provides the location of the data to transfer from Memory Map to Stream."]
        pub type BUF_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BUF_ADDR_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Provides the location of the data to transfer from Memory Map to Stream."]
            #[inline(always)]
            pub fn buf_addr(&self) -> BUF_ADDR_R {
                BUF_ADDR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Provides the location of the data to transfer from Memory Map to Stream."]
            #[inline(always)]
            #[must_use]
            pub fn buf_addr(&mut self) -> BUF_ADDR_W<0> {
                BUF_ADDR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Buffer Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [buf_addr](index.html) module"]
        pub struct BUF_ADDR_SPEC;
        impl crate::RegisterSpec for BUF_ADDR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [buf_addr::R](R) reader structure"]
        impl crate::Readable for BUF_ADDR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [buf_addr::W](W) writer structure"]
        impl crate::Writable for BUF_ADDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets buf_addr to value 0"]
        impl crate::Resettable for BUF_ADDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "buf_addr_msb (rw) register accessor: an alias for `Reg<BUF_ADDR_MSB_SPEC>`"]
    pub type BUF_ADDR_MSB = crate::Reg<buf_addr_msb::BUF_ADDR_MSB_SPEC>;
    #[doc = "Upper 32 bits of Buffer Address"]
    pub mod buf_addr_msb {
        #[doc = "Register `buf_addr_msb` reader"]
        pub struct R(crate::R<BUF_ADDR_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BUF_ADDR_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BUF_ADDR_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BUF_ADDR_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `buf_addr_msb` writer"]
        pub struct W(crate::W<BUF_ADDR_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BUF_ADDR_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BUF_ADDR_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BUF_ADDR_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `buf_addr` reader - Provides the MSB 32 bits of the location of the data to transfer from Memory Map to Stream."]
        pub type BUF_ADDR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `buf_addr` writer - Provides the MSB 32 bits of the location of the data to transfer from Memory Map to Stream."]
        pub type BUF_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BUF_ADDR_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Provides the MSB 32 bits of the location of the data to transfer from Memory Map to Stream."]
            #[inline(always)]
            pub fn buf_addr(&self) -> BUF_ADDR_R {
                BUF_ADDR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Provides the MSB 32 bits of the location of the data to transfer from Memory Map to Stream."]
            #[inline(always)]
            #[must_use]
            pub fn buf_addr(&mut self) -> BUF_ADDR_W<0> {
                BUF_ADDR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Upper 32 bits of Buffer Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [buf_addr_msb](index.html) module"]
        pub struct BUF_ADDR_MSB_SPEC;
        impl crate::RegisterSpec for BUF_ADDR_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [buf_addr_msb::R](R) reader structure"]
        impl crate::Readable for BUF_ADDR_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [buf_addr_msb::W](W) writer structure"]
        impl crate::Writable for BUF_ADDR_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets buf_addr_msb to value 0"]
        impl crate::Resettable for BUF_ADDR_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "control (rw) register accessor: an alias for `Reg<CONTROL_SPEC>`"]
    pub type CONTROL = crate::Reg<control::CONTROL_SPEC>;
    #[doc = ""]
    pub mod control {
        #[doc = "Register `control` reader"]
        pub struct R(crate::R<CONTROL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CONTROL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CONTROL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CONTROL_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `control` writer"]
        pub struct W(crate::W<CONTROL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CONTROL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CONTROL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CONTROL_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `buf_len` reader - Indicates the size in bytes of the transfer buffer. This value indicates the amount of bytes to transmit out on the MM2S stream."]
        pub type BUF_LEN_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `buf_len` writer - Indicates the size in bytes of the transfer buffer. This value indicates the amount of bytes to transmit out on the MM2S stream."]
        pub type BUF_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CONTROL_SPEC, u32, u32, 26, O>;
        #[doc = "Field `txeof` reader - End of Frame. Flag indicating the last buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the end of the packet."]
        pub type TXEOF_R = crate::BitReader<TXEOF_A>;
        #[doc = "End of Frame. Flag indicating the last buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the end of the packet.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TXEOF_A {
            #[doc = "0: `0`"]
            NONE = 0,
            #[doc = "1: `1`"]
            TXEOF = 1,
        }
        impl From<TXEOF_A> for bool {
            #[inline(always)]
            fn from(variant: TXEOF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TXEOF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXEOF_A {
                match self.bits {
                    false => TXEOF_A::NONE,
                    true => TXEOF_A::TXEOF,
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == TXEOF_A::NONE
            }
            #[doc = "Checks if the value of the field is `TXEOF`"]
            #[inline(always)]
            pub fn is_txeof(&self) -> bool {
                *self == TXEOF_A::TXEOF
            }
        }
        #[doc = "Field `txeof` writer - End of Frame. Flag indicating the last buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the end of the packet."]
        pub type TXEOF_W<'a, const O: u8> = crate::BitWriter<'a, u32, CONTROL_SPEC, TXEOF_A, O>;
        impl<'a, const O: u8> TXEOF_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(TXEOF_A::NONE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn txeof(self) -> &'a mut W {
                self.variant(TXEOF_A::TXEOF)
            }
        }
        #[doc = "Field `txsof` reader - Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the start of the packet."]
        pub type TXSOF_R = crate::BitReader<TXSOF_A>;
        #[doc = "Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the start of the packet.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TXSOF_A {
            #[doc = "0: `0`"]
            NONE = 0,
            #[doc = "1: `1`"]
            TXSOF = 1,
        }
        impl From<TXSOF_A> for bool {
            #[inline(always)]
            fn from(variant: TXSOF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TXSOF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXSOF_A {
                match self.bits {
                    false => TXSOF_A::NONE,
                    true => TXSOF_A::TXSOF,
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == TXSOF_A::NONE
            }
            #[doc = "Checks if the value of the field is `TXSOF`"]
            #[inline(always)]
            pub fn is_txsof(&self) -> bool {
                *self == TXSOF_A::TXSOF
            }
        }
        #[doc = "Field `txsof` writer - Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the start of the packet."]
        pub type TXSOF_W<'a, const O: u8> = crate::BitWriter<'a, u32, CONTROL_SPEC, TXSOF_A, O>;
        impl<'a, const O: u8> TXSOF_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(TXSOF_A::NONE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn txsof(self) -> &'a mut W {
                self.variant(TXSOF_A::TXSOF)
            }
        }
        impl R {
            #[doc = "Bits 0:25 - Indicates the size in bytes of the transfer buffer. This value indicates the amount of bytes to transmit out on the MM2S stream."]
            #[inline(always)]
            pub fn buf_len(&self) -> BUF_LEN_R {
                BUF_LEN_R::new(self.bits & 0x03ff_ffff)
            }
            #[doc = "Bit 26 - End of Frame. Flag indicating the last buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the end of the packet."]
            #[inline(always)]
            pub fn txeof(&self) -> TXEOF_R {
                TXEOF_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the start of the packet."]
            #[inline(always)]
            pub fn txsof(&self) -> TXSOF_R {
                TXSOF_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:25 - Indicates the size in bytes of the transfer buffer. This value indicates the amount of bytes to transmit out on the MM2S stream."]
            #[inline(always)]
            #[must_use]
            pub fn buf_len(&mut self) -> BUF_LEN_W<0> {
                BUF_LEN_W::new(self)
            }
            #[doc = "Bit 26 - End of Frame. Flag indicating the last buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the end of the packet."]
            #[inline(always)]
            #[must_use]
            pub fn txeof(&mut self) -> TXEOF_W<26> {
                TXEOF_W::new(self)
            }
            #[doc = "Bit 27 - Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the CPU to indicate to AXI DMA that this descriptor describes the start of the packet."]
            #[inline(always)]
            #[must_use]
            pub fn txsof(&mut self) -> TXSOF_W<27> {
                TXSOF_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [control](index.html) module"]
        pub struct CONTROL_SPEC;
        impl crate::RegisterSpec for CONTROL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [control::R](R) reader structure"]
        impl crate::Readable for CONTROL_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [control::W](W) writer structure"]
        impl crate::Writable for CONTROL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets control to value 0"]
        impl crate::Resettable for CONTROL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "status (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    #[doc = ""]
    pub mod status {
        #[doc = "Register `status` reader"]
        pub struct R(crate::R<STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `tfer_bytes` reader - Indicates the size in bytes of the actual data transferred for this descriptor. This value indicates the amount of bytes to transmit out on MM2S stream."]
        pub type TFER_BYTES_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `dma_int_err` reader - DMA Internal Error. Internal Error detected by primary AXI DataMover. This error can occur if a 0 length bytes to transfer is fed to the AXI DataMover."]
        pub type DMA_INT_ERR_R = crate::BitReader<DMA_INT_ERR_A>;
        #[doc = "DMA Internal Error. Internal Error detected by primary AXI DataMover. This error can occur if a 0 length bytes to transfer is fed to the AXI DataMover.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_INT_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_INT_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_INT_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_INT_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_INT_ERR_A {
                match self.bits {
                    false => DMA_INT_ERR_A::NO_ERR,
                    true => DMA_INT_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_INT_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_INT_ERR_A::DETECTED
            }
        }
        #[doc = "Field `dma_slv_err` reader - DMA Slave Error. Slave Error detected by primary AXI DataMover. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
        pub type DMA_SLV_ERR_R = crate::BitReader<DMA_SLV_ERR_A>;
        #[doc = "DMA Slave Error. Slave Error detected by primary AXI DataMover. This error occurs if the slave read from the Memory Map interface issues a Slave Error.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_SLV_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_SLV_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_SLV_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_SLV_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_SLV_ERR_A {
                match self.bits {
                    false => DMA_SLV_ERR_A::NO_ERR,
                    true => DMA_SLV_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_SLV_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_SLV_ERR_A::DETECTED
            }
        }
        #[doc = "Field `cmplt` reader - Completed. This indicates to the software that the DMA Engine has completed the transfer as described by the associated descriptor."]
        pub type CMPLT_R = crate::BitReader<CMPLT_A>;
        #[doc = "Completed. This indicates to the software that the DMA Engine has completed the transfer as described by the associated descriptor.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CMPLT_A {
            #[doc = "0: `0`"]
            FALSE = 0,
            #[doc = "1: `1`"]
            TRUE = 1,
        }
        impl From<CMPLT_A> for bool {
            #[inline(always)]
            fn from(variant: CMPLT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CMPLT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMPLT_A {
                match self.bits {
                    false => CMPLT_A::FALSE,
                    true => CMPLT_A::TRUE,
                }
            }
            #[doc = "Checks if the value of the field is `FALSE`"]
            #[inline(always)]
            pub fn is_false(&self) -> bool {
                *self == CMPLT_A::FALSE
            }
            #[doc = "Checks if the value of the field is `TRUE`"]
            #[inline(always)]
            pub fn is_true(&self) -> bool {
                *self == CMPLT_A::TRUE
            }
        }
        #[doc = "Field `dma_dec_err` reader - DMA Decode Error. Decode Error detected by primary AXI DataMover. This error occurs if the Descriptor Buffer Address points to an invalid address."]
        pub type DMA_DEC_ERR_R = crate::BitReader<DMA_DEC_ERR_A>;
        #[doc = "DMA Decode Error. Decode Error detected by primary AXI DataMover. This error occurs if the Descriptor Buffer Address points to an invalid address.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_DEC_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_DEC_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_DEC_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_DEC_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_DEC_ERR_A {
                match self.bits {
                    false => DMA_DEC_ERR_A::NO_ERR,
                    true => DMA_DEC_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_DEC_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_DEC_ERR_A::DETECTED
            }
        }
        impl R {
            #[doc = "Bits 0:25 - Indicates the size in bytes of the actual data transferred for this descriptor. This value indicates the amount of bytes to transmit out on MM2S stream."]
            #[inline(always)]
            pub fn tfer_bytes(&self) -> TFER_BYTES_R {
                TFER_BYTES_R::new(self.bits & 0x03ff_ffff)
            }
            #[doc = "Bit 28 - DMA Internal Error. Internal Error detected by primary AXI DataMover. This error can occur if a 0 length bytes to transfer is fed to the AXI DataMover."]
            #[inline(always)]
            pub fn dma_int_err(&self) -> DMA_INT_ERR_R {
                DMA_INT_ERR_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - DMA Slave Error. Slave Error detected by primary AXI DataMover. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
            #[inline(always)]
            pub fn dma_slv_err(&self) -> DMA_SLV_ERR_R {
                DMA_SLV_ERR_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 29 - Completed. This indicates to the software that the DMA Engine has completed the transfer as described by the associated descriptor."]
            #[inline(always)]
            pub fn cmplt(&self) -> CMPLT_R {
                CMPLT_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - DMA Decode Error. Decode Error detected by primary AXI DataMover. This error occurs if the Descriptor Buffer Address points to an invalid address."]
            #[inline(always)]
            pub fn dma_dec_err(&self) -> DMA_DEC_ERR_R {
                DMA_DEC_ERR_R::new(((self.bits >> 30) & 1) != 0)
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [status::R](R) reader structure"]
        impl crate::Readable for STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets status to value 0"]
        impl crate::Resettable for STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "app (r) register accessor: an alias for `Reg<APP_SPEC>`"]
    pub type APP = crate::Reg<app::APP_SPEC>;
    #[doc = "User Application Field \\[%s\\]"]
    pub mod app {
        #[doc = "Register `app[%s]` reader"]
        pub struct R(crate::R<APP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APP_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `app` reader - Specifies user-specific application data. When Status Control Stream is enabled, the Application (APP) fields of the Start of Frame (SOF) Descriptor are transmitted to the AXI Control Stream."]
        pub type APP_R = crate::FieldReader<u32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Specifies user-specific application data. When Status Control Stream is enabled, the Application (APP) fields of the Start of Frame (SOF) Descriptor are transmitted to the AXI Control Stream."]
            #[inline(always)]
            pub fn app(&self) -> APP_R {
                APP_R::new(self.bits)
            }
        }
        #[doc = "User Application Field \\[%s\\]\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [app](index.html) module"]
        pub struct APP_SPEC;
        impl crate::RegisterSpec for APP_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [app::R](R) reader structure"]
        impl crate::Readable for APP_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets app[%s]
to value 0"]
        impl crate::Resettable for APP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Scatter Gather Descriptor"]
pub struct S2MM_SG_DESC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for S2MM_SG_DESC {}
impl S2MM_SG_DESC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const s2mm_sg_desc::RegisterBlock = 0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const s2mm_sg_desc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for S2MM_SG_DESC {
    type Target = s2mm_sg_desc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for S2MM_SG_DESC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("S2MM_SG_DESC").finish()
    }
}
#[doc = "Scatter Gather Descriptor"]
pub mod s2mm_sg_desc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Next Descriptor Pointer"]
        pub nxt_desc: NXT_DESC,
        #[doc = "0x04 - Upper 32 bits of Next Descriptor Pointer"]
        pub nxt_desc_msb: NXT_DESC_MSB,
        #[doc = "0x08 - Buffer Address"]
        pub buf_addr: BUF_ADDR,
        #[doc = "0x0c - Upper 32 bits of Buffer Address"]
        pub buf_addr_msb: BUF_ADDR_MSB,
        _reserved4: [u8; 0x08],
        #[doc = "0x18 - "]
        pub control: CONTROL,
        #[doc = "0x1c - "]
        pub status: STATUS,
        #[doc = "0x20..0x34 - User Application Field \\[%s\\]"]
        pub app: [APP; 5],
    }
    #[doc = "nxt_desc (rw) register accessor: an alias for `Reg<NXT_DESC_SPEC>`"]
    pub type NXT_DESC = crate::Reg<nxt_desc::NXT_DESC_SPEC>;
    #[doc = "Next Descriptor Pointer"]
    pub mod nxt_desc {
        #[doc = "Register `nxt_desc` reader"]
        pub struct R(crate::R<NXT_DESC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<NXT_DESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<NXT_DESC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<NXT_DESC_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `nxt_desc` writer"]
        pub struct W(crate::W<NXT_DESC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<NXT_DESC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<NXT_DESC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<NXT_DESC_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `nxt_desc_ptr` reader - Indicates the lower order pointer pointing to the first word of the next descriptor"]
        pub type NXT_DESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `nxt_desc_ptr` writer - Indicates the lower order pointer pointing to the first word of the next descriptor"]
        pub type NXT_DESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, NXT_DESC_SPEC, u32, u32, 26, O>;
        impl R {
            #[doc = "Bits 6:31 - Indicates the lower order pointer pointing to the first word of the next descriptor"]
            #[inline(always)]
            pub fn nxt_desc_ptr(&self) -> NXT_DESC_PTR_R {
                NXT_DESC_PTR_R::new((self.bits >> 6) & 0x03ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 6:31 - Indicates the lower order pointer pointing to the first word of the next descriptor"]
            #[inline(always)]
            #[must_use]
            pub fn nxt_desc_ptr(&mut self) -> NXT_DESC_PTR_W<6> {
                NXT_DESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Next Descriptor Pointer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nxt_desc](index.html) module"]
        pub struct NXT_DESC_SPEC;
        impl crate::RegisterSpec for NXT_DESC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [nxt_desc::R](R) reader structure"]
        impl crate::Readable for NXT_DESC_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [nxt_desc::W](W) writer structure"]
        impl crate::Writable for NXT_DESC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets nxt_desc to value 0"]
        impl crate::Resettable for NXT_DESC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "nxt_desc_msb (rw) register accessor: an alias for `Reg<NXT_DESC_MSB_SPEC>`"]
    pub type NXT_DESC_MSB = crate::Reg<nxt_desc_msb::NXT_DESC_MSB_SPEC>;
    #[doc = "Upper 32 bits of Next Descriptor Pointer"]
    pub mod nxt_desc_msb {
        #[doc = "Register `nxt_desc_msb` reader"]
        pub struct R(crate::R<NXT_DESC_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<NXT_DESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<NXT_DESC_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<NXT_DESC_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `nxt_desc_msb` writer"]
        pub struct W(crate::W<NXT_DESC_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<NXT_DESC_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<NXT_DESC_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<NXT_DESC_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `nxt_desc_ptr` reader - Indicates the MSB 32 bits of the pointer pointing to the first word of the next descriptor"]
        pub type NXT_DESC_PTR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `nxt_desc_ptr` writer - Indicates the MSB 32 bits of the pointer pointing to the first word of the next descriptor"]
        pub type NXT_DESC_PTR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, NXT_DESC_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Indicates the MSB 32 bits of the pointer pointing to the first word of the next descriptor"]
            #[inline(always)]
            pub fn nxt_desc_ptr(&self) -> NXT_DESC_PTR_R {
                NXT_DESC_PTR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Indicates the MSB 32 bits of the pointer pointing to the first word of the next descriptor"]
            #[inline(always)]
            #[must_use]
            pub fn nxt_desc_ptr(&mut self) -> NXT_DESC_PTR_W<0> {
                NXT_DESC_PTR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Upper 32 bits of Next Descriptor Pointer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nxt_desc_msb](index.html) module"]
        pub struct NXT_DESC_MSB_SPEC;
        impl crate::RegisterSpec for NXT_DESC_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [nxt_desc_msb::R](R) reader structure"]
        impl crate::Readable for NXT_DESC_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [nxt_desc_msb::W](W) writer structure"]
        impl crate::Writable for NXT_DESC_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets nxt_desc_msb to value 0"]
        impl crate::Resettable for NXT_DESC_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "buf_addr (rw) register accessor: an alias for `Reg<BUF_ADDR_SPEC>`"]
    pub type BUF_ADDR = crate::Reg<buf_addr::BUF_ADDR_SPEC>;
    #[doc = "Buffer Address"]
    pub mod buf_addr {
        #[doc = "Register `buf_addr` reader"]
        pub struct R(crate::R<BUF_ADDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BUF_ADDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BUF_ADDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BUF_ADDR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `buf_addr` writer"]
        pub struct W(crate::W<BUF_ADDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BUF_ADDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BUF_ADDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BUF_ADDR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `buf_addr` reader - Provides the location of the data to transfer from Stream to Memory Map."]
        pub type BUF_ADDR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `buf_addr` writer - Provides the location of the data to transfer from Stream to Memory Map."]
        pub type BUF_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BUF_ADDR_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Provides the location of the data to transfer from Stream to Memory Map."]
            #[inline(always)]
            pub fn buf_addr(&self) -> BUF_ADDR_R {
                BUF_ADDR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Provides the location of the data to transfer from Stream to Memory Map."]
            #[inline(always)]
            #[must_use]
            pub fn buf_addr(&mut self) -> BUF_ADDR_W<0> {
                BUF_ADDR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Buffer Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [buf_addr](index.html) module"]
        pub struct BUF_ADDR_SPEC;
        impl crate::RegisterSpec for BUF_ADDR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [buf_addr::R](R) reader structure"]
        impl crate::Readable for BUF_ADDR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [buf_addr::W](W) writer structure"]
        impl crate::Writable for BUF_ADDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets buf_addr to value 0"]
        impl crate::Resettable for BUF_ADDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "buf_addr_msb (rw) register accessor: an alias for `Reg<BUF_ADDR_MSB_SPEC>`"]
    pub type BUF_ADDR_MSB = crate::Reg<buf_addr_msb::BUF_ADDR_MSB_SPEC>;
    #[doc = "Upper 32 bits of Buffer Address"]
    pub mod buf_addr_msb {
        #[doc = "Register `buf_addr_msb` reader"]
        pub struct R(crate::R<BUF_ADDR_MSB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BUF_ADDR_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BUF_ADDR_MSB_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BUF_ADDR_MSB_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `buf_addr_msb` writer"]
        pub struct W(crate::W<BUF_ADDR_MSB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BUF_ADDR_MSB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BUF_ADDR_MSB_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BUF_ADDR_MSB_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `buf_addr` reader - Provides the MSB 32 bits of the location of the data to transfer from Stream to Memory Map."]
        pub type BUF_ADDR_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `buf_addr` writer - Provides the MSB 32 bits of the location of the data to transfer from Stream to Memory Map."]
        pub type BUF_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BUF_ADDR_MSB_SPEC, u32, u32, 32, O>;
        impl R {
            #[doc = "Bits 0:31 - Provides the MSB 32 bits of the location of the data to transfer from Stream to Memory Map."]
            #[inline(always)]
            pub fn buf_addr(&self) -> BUF_ADDR_R {
                BUF_ADDR_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Provides the MSB 32 bits of the location of the data to transfer from Stream to Memory Map."]
            #[inline(always)]
            #[must_use]
            pub fn buf_addr(&mut self) -> BUF_ADDR_W<0> {
                BUF_ADDR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "Upper 32 bits of Buffer Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [buf_addr_msb](index.html) module"]
        pub struct BUF_ADDR_MSB_SPEC;
        impl crate::RegisterSpec for BUF_ADDR_MSB_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [buf_addr_msb::R](R) reader structure"]
        impl crate::Readable for BUF_ADDR_MSB_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [buf_addr_msb::W](W) writer structure"]
        impl crate::Writable for BUF_ADDR_MSB_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets buf_addr_msb to value 0"]
        impl crate::Resettable for BUF_ADDR_MSB_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "control (rw) register accessor: an alias for `Reg<CONTROL_SPEC>`"]
    pub type CONTROL = crate::Reg<control::CONTROL_SPEC>;
    #[doc = ""]
    pub mod control {
        #[doc = "Register `control` reader"]
        pub struct R(crate::R<CONTROL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CONTROL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CONTROL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CONTROL_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `control` writer"]
        pub struct W(crate::W<CONTROL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CONTROL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CONTROL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CONTROL_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `buf_len` reader - Indicates the amount of space in bytes available for receiving data in an S2MM stream."]
        pub type BUF_LEN_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `buf_len` writer - Indicates the amount of space in bytes available for receiving data in an S2MM stream."]
        pub type BUF_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CONTROL_SPEC, u32, u32, 26, O>;
        #[doc = "Field `rxeof` reader - End of Frame. Flag indicating the last buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the end of the packet."]
        pub type RXEOF_R = crate::BitReader<RXEOF_A>;
        #[doc = "End of Frame. Flag indicating the last buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the end of the packet.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXEOF_A {
            #[doc = "0: `0`"]
            FALSE = 0,
            #[doc = "1: `1`"]
            TRUE = 1,
        }
        impl From<RXEOF_A> for bool {
            #[inline(always)]
            fn from(variant: RXEOF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXEOF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXEOF_A {
                match self.bits {
                    false => RXEOF_A::FALSE,
                    true => RXEOF_A::TRUE,
                }
            }
            #[doc = "Checks if the value of the field is `FALSE`"]
            #[inline(always)]
            pub fn is_false(&self) -> bool {
                *self == RXEOF_A::FALSE
            }
            #[doc = "Checks if the value of the field is `TRUE`"]
            #[inline(always)]
            pub fn is_true(&self) -> bool {
                *self == RXEOF_A::TRUE
            }
        }
        #[doc = "Field `rxeof` writer - End of Frame. Flag indicating the last buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the end of the packet."]
        pub type RXEOF_W<'a, const O: u8> = crate::BitWriter<'a, u32, CONTROL_SPEC, RXEOF_A, O>;
        impl<'a, const O: u8> RXEOF_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn false_(self) -> &'a mut W {
                self.variant(RXEOF_A::FALSE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn true_(self) -> &'a mut W {
                self.variant(RXEOF_A::TRUE)
            }
        }
        #[doc = "Field `rxsof` reader - Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the start of the packet."]
        pub type RXSOF_R = crate::BitReader<RXSOF_A>;
        #[doc = "Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the start of the packet.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXSOF_A {
            #[doc = "0: `0`"]
            FALSE = 0,
            #[doc = "1: `1`"]
            TRUE = 1,
        }
        impl From<RXSOF_A> for bool {
            #[inline(always)]
            fn from(variant: RXSOF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXSOF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXSOF_A {
                match self.bits {
                    false => RXSOF_A::FALSE,
                    true => RXSOF_A::TRUE,
                }
            }
            #[doc = "Checks if the value of the field is `FALSE`"]
            #[inline(always)]
            pub fn is_false(&self) -> bool {
                *self == RXSOF_A::FALSE
            }
            #[doc = "Checks if the value of the field is `TRUE`"]
            #[inline(always)]
            pub fn is_true(&self) -> bool {
                *self == RXSOF_A::TRUE
            }
        }
        #[doc = "Field `rxsof` writer - Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the start of the packet."]
        pub type RXSOF_W<'a, const O: u8> = crate::BitWriter<'a, u32, CONTROL_SPEC, RXSOF_A, O>;
        impl<'a, const O: u8> RXSOF_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn false_(self) -> &'a mut W {
                self.variant(RXSOF_A::FALSE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn true_(self) -> &'a mut W {
                self.variant(RXSOF_A::TRUE)
            }
        }
        impl R {
            #[doc = "Bits 0:25 - Indicates the amount of space in bytes available for receiving data in an S2MM stream."]
            #[inline(always)]
            pub fn buf_len(&self) -> BUF_LEN_R {
                BUF_LEN_R::new(self.bits & 0x03ff_ffff)
            }
            #[doc = "Bit 26 - End of Frame. Flag indicating the last buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the end of the packet."]
            #[inline(always)]
            pub fn rxeof(&self) -> RXEOF_R {
                RXEOF_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the start of the packet."]
            #[inline(always)]
            pub fn rxsof(&self) -> RXSOF_R {
                RXSOF_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:25 - Indicates the amount of space in bytes available for receiving data in an S2MM stream."]
            #[inline(always)]
            #[must_use]
            pub fn buf_len(&mut self) -> BUF_LEN_W<0> {
                BUF_LEN_W::new(self)
            }
            #[doc = "Bit 26 - End of Frame. Flag indicating the last buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the end of the packet."]
            #[inline(always)]
            #[must_use]
            pub fn rxeof(&mut self) -> RXEOF_W<26> {
                RXEOF_W::new(self)
            }
            #[doc = "Bit 27 - Start of Frame. Flag indicating the first buffer to be processed. This flag is set by the sw/user to indicate to AXI DMA that this descriptor describes the start of the packet."]
            #[inline(always)]
            #[must_use]
            pub fn rxsof(&mut self) -> RXSOF_W<27> {
                RXSOF_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [control](index.html) module"]
        pub struct CONTROL_SPEC;
        impl crate::RegisterSpec for CONTROL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [control::R](R) reader structure"]
        impl crate::Readable for CONTROL_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [control::W](W) writer structure"]
        impl crate::Writable for CONTROL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets control to value 0"]
        impl crate::Resettable for CONTROL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "status (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    #[doc = ""]
    pub mod status {
        #[doc = "Register `status` reader"]
        pub struct R(crate::R<STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `tfer_bytes` reader - This value indicates the amount of data received and stored in the buffer described by this descriptor. This might or might not match the buffer length."]
        pub type TFER_BYTES_R = crate::FieldReader<u32, u32>;
        #[doc = "Field `rxeof` reader - End of Frame. Flag indicating buffer holds the last part of packet. This bit is set by AXI DMA to indicate to the sw/user that the buffer associated with this descriptor contains the end of the packet."]
        pub type RXEOF_R = crate::BitReader<RXEOF_A>;
        #[doc = "End of Frame. Flag indicating buffer holds the last part of packet. This bit is set by AXI DMA to indicate to the sw/user that the buffer associated with this descriptor contains the end of the packet.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXEOF_A {
            #[doc = "0: `0`"]
            FALSE = 0,
            #[doc = "1: `1`"]
            TRUE = 1,
        }
        impl From<RXEOF_A> for bool {
            #[inline(always)]
            fn from(variant: RXEOF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXEOF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXEOF_A {
                match self.bits {
                    false => RXEOF_A::FALSE,
                    true => RXEOF_A::TRUE,
                }
            }
            #[doc = "Checks if the value of the field is `FALSE`"]
            #[inline(always)]
            pub fn is_false(&self) -> bool {
                *self == RXEOF_A::FALSE
            }
            #[doc = "Checks if the value of the field is `TRUE`"]
            #[inline(always)]
            pub fn is_true(&self) -> bool {
                *self == RXEOF_A::TRUE
            }
        }
        #[doc = "Field `rxsof` reader - Start of Frame. Flag indicating buffer holds first part of packet. This bit is set by AXI DMA to indicate to the sw/user that the buffer associated with this descriptor contains the start of the packet."]
        pub type RXSOF_R = crate::BitReader<RXSOF_A>;
        #[doc = "Start of Frame. Flag indicating buffer holds first part of packet. This bit is set by AXI DMA to indicate to the sw/user that the buffer associated with this descriptor contains the start of the packet.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXSOF_A {
            #[doc = "0: `0`"]
            FALSE = 0,
            #[doc = "1: `1`"]
            TRUE = 1,
        }
        impl From<RXSOF_A> for bool {
            #[inline(always)]
            fn from(variant: RXSOF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXSOF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXSOF_A {
                match self.bits {
                    false => RXSOF_A::FALSE,
                    true => RXSOF_A::TRUE,
                }
            }
            #[doc = "Checks if the value of the field is `FALSE`"]
            #[inline(always)]
            pub fn is_false(&self) -> bool {
                *self == RXSOF_A::FALSE
            }
            #[doc = "Checks if the value of the field is `TRUE`"]
            #[inline(always)]
            pub fn is_true(&self) -> bool {
                *self == RXSOF_A::TRUE
            }
        }
        #[doc = "Field `dma_int_err` reader - DMA Internal Error. Internal Error detected by primary AXI DataMover. This error can occur if a 0 length bytes to transfer is fed to the AXI DataMover."]
        pub type DMA_INT_ERR_R = crate::BitReader<DMA_INT_ERR_A>;
        #[doc = "DMA Internal Error. Internal Error detected by primary AXI DataMover. This error can occur if a 0 length bytes to transfer is fed to the AXI DataMover.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_INT_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_INT_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_INT_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_INT_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_INT_ERR_A {
                match self.bits {
                    false => DMA_INT_ERR_A::NO_ERR,
                    true => DMA_INT_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_INT_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_INT_ERR_A::DETECTED
            }
        }
        #[doc = "Field `dma_slv_err` reader - DMA Slave Error. Slave Error detected by primary AXI DataMover. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
        pub type DMA_SLV_ERR_R = crate::BitReader<DMA_SLV_ERR_A>;
        #[doc = "DMA Slave Error. Slave Error detected by primary AXI DataMover. This error occurs if the slave read from the Memory Map interface issues a Slave Error.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_SLV_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_SLV_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_SLV_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_SLV_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_SLV_ERR_A {
                match self.bits {
                    false => DMA_SLV_ERR_A::NO_ERR,
                    true => DMA_SLV_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_SLV_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_SLV_ERR_A::DETECTED
            }
        }
        #[doc = "Field `cmplt` reader - Completed. This indicates to the software that the DMA Engine has completed the transfer as described by the associated descriptor."]
        pub type CMPLT_R = crate::BitReader<CMPLT_A>;
        #[doc = "Completed. This indicates to the software that the DMA Engine has completed the transfer as described by the associated descriptor.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CMPLT_A {
            #[doc = "0: `0`"]
            FALSE = 0,
            #[doc = "1: `1`"]
            TRUE = 1,
        }
        impl From<CMPLT_A> for bool {
            #[inline(always)]
            fn from(variant: CMPLT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CMPLT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMPLT_A {
                match self.bits {
                    false => CMPLT_A::FALSE,
                    true => CMPLT_A::TRUE,
                }
            }
            #[doc = "Checks if the value of the field is `FALSE`"]
            #[inline(always)]
            pub fn is_false(&self) -> bool {
                *self == CMPLT_A::FALSE
            }
            #[doc = "Checks if the value of the field is `TRUE`"]
            #[inline(always)]
            pub fn is_true(&self) -> bool {
                *self == CMPLT_A::TRUE
            }
        }
        #[doc = "Field `dma_dec_err` reader - DMA Decode Error. Decode Error detected by primary AXI DataMover. This error occurs if the Descriptor Buffer Address points to an invalid address."]
        pub type DMA_DEC_ERR_R = crate::BitReader<DMA_DEC_ERR_A>;
        #[doc = "DMA Decode Error. Decode Error detected by primary AXI DataMover. This error occurs if the Descriptor Buffer Address points to an invalid address.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_DEC_ERR_A {
            #[doc = "0: `0`"]
            NO_ERR = 0,
            #[doc = "1: `1`"]
            DETECTED = 1,
        }
        impl From<DMA_DEC_ERR_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_DEC_ERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_DEC_ERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_DEC_ERR_A {
                match self.bits {
                    false => DMA_DEC_ERR_A::NO_ERR,
                    true => DMA_DEC_ERR_A::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_ERR`"]
            #[inline(always)]
            pub fn is_no_err(&self) -> bool {
                *self == DMA_DEC_ERR_A::NO_ERR
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == DMA_DEC_ERR_A::DETECTED
            }
        }
        impl R {
            #[doc = "Bits 0:25 - This value indicates the amount of data received and stored in the buffer described by this descriptor. This might or might not match the buffer length."]
            #[inline(always)]
            pub fn tfer_bytes(&self) -> TFER_BYTES_R {
                TFER_BYTES_R::new(self.bits & 0x03ff_ffff)
            }
            #[doc = "Bit 26 - End of Frame. Flag indicating buffer holds the last part of packet. This bit is set by AXI DMA to indicate to the sw/user that the buffer associated with this descriptor contains the end of the packet."]
            #[inline(always)]
            pub fn rxeof(&self) -> RXEOF_R {
                RXEOF_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - Start of Frame. Flag indicating buffer holds first part of packet. This bit is set by AXI DMA to indicate to the sw/user that the buffer associated with this descriptor contains the start of the packet."]
            #[inline(always)]
            pub fn rxsof(&self) -> RXSOF_R {
                RXSOF_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - DMA Internal Error. Internal Error detected by primary AXI DataMover. This error can occur if a 0 length bytes to transfer is fed to the AXI DataMover."]
            #[inline(always)]
            pub fn dma_int_err(&self) -> DMA_INT_ERR_R {
                DMA_INT_ERR_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - DMA Slave Error. Slave Error detected by primary AXI DataMover. This error occurs if the slave read from the Memory Map interface issues a Slave Error."]
            #[inline(always)]
            pub fn dma_slv_err(&self) -> DMA_SLV_ERR_R {
                DMA_SLV_ERR_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 29 - Completed. This indicates to the software that the DMA Engine has completed the transfer as described by the associated descriptor."]
            #[inline(always)]
            pub fn cmplt(&self) -> CMPLT_R {
                CMPLT_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - DMA Decode Error. Decode Error detected by primary AXI DataMover. This error occurs if the Descriptor Buffer Address points to an invalid address."]
            #[inline(always)]
            pub fn dma_dec_err(&self) -> DMA_DEC_ERR_R {
                DMA_DEC_ERR_R::new(((self.bits >> 30) & 1) != 0)
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [status::R](R) reader structure"]
        impl crate::Readable for STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets status to value 0"]
        impl crate::Resettable for STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "app (r) register accessor: an alias for `Reg<APP_SPEC>`"]
    pub type APP = crate::Reg<app::APP_SPEC>;
    #[doc = "User Application Field \\[%s\\]"]
    pub mod app {
        #[doc = "Register `app[%s]` reader"]
        pub struct R(crate::R<APP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APP_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `app` reader - Specifies user-specific application data. When Status Control Stream is enabled, the Application (APP) fields of the Start of Frame (SOF) Descriptor are transmitted to the AXI Control Stream."]
        pub type APP_R = crate::FieldReader<u32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Specifies user-specific application data. When Status Control Stream is enabled, the Application (APP) fields of the Start of Frame (SOF) Descriptor are transmitted to the AXI Control Stream."]
            #[inline(always)]
            pub fn app(&self) -> APP_R {
                APP_R::new(self.bits)
            }
        }
        #[doc = "User Application Field \\[%s\\]\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [app](index.html) module"]
        pub struct APP_SPEC;
        impl crate::RegisterSpec for APP_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [app::R](R) reader structure"]
        impl crate::Readable for APP_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets app[%s]
to value 0"]
        impl crate::Resettable for APP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "AXI_DMA"]
    pub AXI_DMA: AXI_DMA,
    #[doc = "MM2S_SG_DESC"]
    pub MM2S_SG_DESC: MM2S_SG_DESC,
    #[doc = "S2MM_SG_DESC"]
    pub S2MM_SG_DESC: S2MM_SG_DESC,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            AXI_DMA: AXI_DMA {
                _marker: PhantomData,
            },
            MM2S_SG_DESC: MM2S_SG_DESC {
                _marker: PhantomData,
            },
            S2MM_SG_DESC: S2MM_SG_DESC {
                _marker: PhantomData,
            },
        }
    }
}
